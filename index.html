<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MermaidEase Pro - Enhanced Diagram Editor</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --background-light: #f8f9fa;
            --text-dark: #2c3e50;
            --border-color: #e0e0e0;
            --node-color: #ecf0f1;
            --node-border: #2c3e50;
            --edge-color: #3498db;
            --header-bg: #f1f1f1;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            --shadow-hover: 0 6px 16px rgba(0, 0, 0, 0.12);
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            background: var(--background-light);
            color: var(--text-dark);
            height: 100vh;
            overflow: hidden;
        }

        /* Mobile-first responsive design */
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        @media (min-width: 768px) {
            .container {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 16px;
                padding: 16px;
            }
        }

        @media (min-width: 1200px) {
            .container {
                gap: 24px;
                padding: 24px;
            }
        }

        .panel {
            background: white;
            border-radius: 12px;
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-header {
            background: var(--header-bg);
            padding: 16px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-header h2 {
            margin: 0;
            color: var(--primary-color);
            font-weight: 700;
            font-size: 1.2rem;
        }

        .editor-panel {
            flex: 1;
            min-height: 50vh;
        }

        .preview-panel {
            flex: 1;
            min-height: 50vh;
            position: relative;
        }

        @media (min-width: 768px) {

            .editor-panel,
            .preview-panel {
                min-height: calc(100vh - 32px);
            }
        }

        /* Code Editor */
        .editor-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 16px;
        }

        #code {
            flex: 1;
            padding: 16px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            resize: none;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            background: #fafafa;
            transition: border-color 0.3s ease;
            min-height: 200px;
        }

        #code:focus {
            border-color: var(--primary-color);
            outline: none;
        }

        /* Controls */
        .controls-row {
            display: flex;
            gap: 8px;
            margin: 16px 0;
            flex-wrap: wrap;
        }

        .btn {
            background: var(--primary-color);
            color: white;
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn:hover {
            background: var(--text-dark);
            transform: translateY(-1px);
            box-shadow: var(--shadow);
        }

        .btn.secondary {
            background: var(--secondary-color);
        }

        .btn.success {
            background: var(--success-color);
        }

        .btn.small {
            padding: 6px 12px;
            font-size: 11px;
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        /* Dropdown */
        .dropdown {
            position: relative;
            display: inline-block;
            z-index: 1000;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background: white;
            min-width: 200px;
            box-shadow: var(--shadow-hover);
            z-index: 2000;
            border-radius: 8px;
            overflow: hidden;
            top: 100%;
            left: 0;
            border: 1px solid var(--border-color);
            max-height: 300px;
            overflow-y: auto;
        }

        /* Force dropdown to open upward when near bottom of viewport */
        .dropdown-content.dropdown-up {
            bottom: 100%;
            top: auto;
        }

        /* Ensure dropdown is fully visible */
        .dropdown-content.dropdown-right {
            left: auto;
            right: 0;
        }

        .dropdown-content.show {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        .dropdown-item {
            padding: 12px 16px;
            cursor: pointer;
            transition: background 0.2s;
            border-bottom: 1px solid #f0f0f0;
        }

        .dropdown-item:hover {
            background: #f8f9fa;
        }

        .dropdown-item:last-child {
            border-bottom: none;
        }

        /* Preview Panel */
        .preview-content {
            flex: 1;
            overflow: auto;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #fff;
            min-height: 400px;
        }

        .preview-controls {
            position: absolute;
            top: 80px;
            right: 16px;
            z-index: 100;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: flex-start;
        }

        .control-btn {
            background: rgba(44, 62, 80, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.2s ease;
        }

        .control-btn:hover {
            background: var(--primary-color);
            transform: scale(1.05);
        }

        .control-btn.active {
            background: var(--warning-color);
        }

        /* Status indicators */
        .status-bar {
            position: absolute;
            bottom: 16px;
            left: 16px;
            right: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 50;
        }

        .zoom-info {
            background: rgba(255, 255, 255, 0.9);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
        }

        /* Grid overlay */
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            opacity: 0.1;
            background-image:
                linear-gradient(to right, #000 1px, transparent 1px),
                linear-gradient(to bottom, #000 1px, transparent 1px);
            background-size: 20px 20px;
            display: none;
        }

        .grid-overlay.active {
            display: block;
        }

        /* Mermaid styling */
        .mermaid {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            transition: transform 0.2s ease;
            /* Ensure proper sizing and overflow handling */
            max-width: 100%;
            max-height: 100%;
            overflow: visible;
        }

        .mermaid svg {
            /* Fix SVG sizing issues */
            max-width: 100%;
            height: auto;
            /* Ensure SVG is not cut off */
            overflow: visible;
        }



        /* Active button state */
        .btn.active {
            background: #3498db;
            color: white;
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
        }



        /* Settings panel */
        .settings-panel {
            position: absolute;
            top: 130px;
            right: 16px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: var(--shadow-hover);
            z-index: 1500;
            width: 280px;
            max-height: 70vh;
            overflow-y: auto;
            display: none;
            border: 1px solid var(--border-color);
        }

        .settings-panel.active {
            display: block;
        }

        .settings-group {
            margin-bottom: 20px;
        }

        .settings-group h4 {
            margin: 0 0 12px 0;
            color: var(--primary-color);
            font-size: 14px;
            font-weight: 600;
        }

        .setting-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .setting-item label {
            flex: 1;
            font-size: 14px;
            margin-right: 8px;
        }

        .setting-item input,
        .setting-item select {
            width: 80px;
            padding: 4px 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 12px;
        }

        /* Loading and error states */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 150;
        }

        .loading-overlay.active {
            display: flex;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--secondary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 12px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .error-message {
            background: #ffe3e6;
            color: #dc3545;
            padding: 12px;
            border-radius: 6px;
            margin: 8px 0;
            font-size: 14px;
            display: none;
        }

        .error-message.active {
            display: block;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .success-message.show {
            transform: translateX(0);
        }

        /* Fullscreen mode */
        .preview-panel.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
            background: white;
        }

        /* Auto-save indicator */
        .auto-save-indicator {
            font-size: 12px;
            color: #666;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .auto-save-indicator.saving {
            color: var(--warning-color);
        }

        .auto-save-indicator.saved {
            color: var(--success-color);
        }

        /* Keyboard shortcuts help */
        .shortcuts-help {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: var(--shadow-hover);
            z-index: 2000;
            max-width: 400px;
            display: none;
        }

        .shortcuts-help.active {
            display: block;
        }

        /* Tutorial Modal */
        .tutorial-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 3000;
            display: none;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
        }

        .tutorial-modal.active {
            display: flex;
        }

        .tutorial-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 1000px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
        }

        .tutorial-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 30px;
            border-bottom: 1px solid #eee;
            background: var(--primary-color);
            color: white;
            border-radius: 12px 12px 0 0;
        }

        .tutorial-header h2 {
            margin: 0;
            font-size: 24px;
        }

        .tutorial-close {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tutorial-close:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .tutorial-links {
            padding: 20px 30px;
            border-bottom: 1px solid #eee;
        }

        .tutorial-links h3 {
            margin: 0 0 15px 0;
            color: var(--primary-color);
        }

        .link-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
        }

        .tutorial-link {
            display: block;
            padding: 12px 16px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            text-decoration: none;
            color: var(--primary-color);
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .tutorial-link:hover {
            background: var(--primary-color);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .tutorial-tabs {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .tab-buttons {
            display: flex;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
        }

        .tab-btn {
            background: none;
            border: none;
            padding: 15px 20px;
            cursor: pointer;
            font-weight: 500;
            color: #666;
            border-bottom: 3px solid transparent;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .tab-btn:hover {
            background: #e9ecef;
            color: var(--primary-color);
        }

        .tab-btn.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
            background: white;
        }

        .tab-content {
            flex: 1;
            overflow-y: auto;
            padding: 0;
        }

        .tab-panel {
            display: none;
            padding: 30px;
        }

        .tab-panel.active {
            display: block;
        }

        .tab-panel h3 {
            margin: 0 0 20px 0;
            color: var(--primary-color);
            font-size: 20px;
        }

        .syntax-section {
            margin-bottom: 30px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            overflow: hidden;
        }

        .syntax-section h4 {
            margin: 0;
            padding: 15px 20px;
            background: #f8f9fa;
            color: var(--primary-color);
            font-size: 16px;
            border-bottom: 1px solid #dee2e6;
        }

        .syntax-section pre {
            margin: 0;
            padding: 20px;
            background: #f8f9fa;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
        }

        .syntax-section code {
            color: #333;
        }

        .copy-btn {
            margin: 15px 20px 20px;
            padding: 8px 16px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .copy-btn:hover {
            background: var(--secondary-color);
            transform: translateY(-1px);
        }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .shortcut-key {
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
        }

        /* Mobile optimizations */
        @media (max-width: 767px) {
            .container {
                padding: 8px;
                gap: 8px;
            }

            .panel-header {
                padding: 12px;
            }

            .editor-content {
                padding: 12px;
            }

            .controls-row {
                gap: 6px;
                flex-wrap: wrap;
            }

            .btn {
                padding: 8px 12px;
                font-size: 11px;
                flex: 1;
                min-width: 80px;
            }

            .preview-controls {
                top: 8px;
                right: 8px;
                gap: 4px;
                flex-direction: column;
            }

            .control-btn {
                width: 36px;
                height: 36px;
                font-size: 14px;
            }

            .settings-panel {
                top: 50px;
                right: 8px;
                left: 8px;
                width: auto;
                max-height: 60vh;
            }

            .dropdown-content {
                min-width: 150px;
                max-width: 90vw;
            }
        }

        /* Dark mode support */
        @media (prefers-color-scheme: dark) {
            :root {
                --background-light: #1a1a1a;
                --text-dark: #e0e0e0;
                --header-bg: #2d2d2d;
                --border-color: #404040;
            }

            .panel {
                background: #2d2d2d;
            }

            #code {
                background: #1e1e1e;
                color: #e0e0e0;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Editor Panel -->
        <div class="panel editor-panel">
            <div class="panel-header">
                <h2>üé® MermaidEase Pro</h2>
                <div class="auto-save-indicator" id="autoSaveIndicator">
                    <span id="autoSaveText">Auto-save</span>
                </div>
            </div>
            <div class="editor-content">
                <textarea id="code" placeholder="Enter your Mermaid diagram code here...">graph TD
    A[üöÄ Start] --> B{üìã Decision}
    B -->|‚úÖ Yes| C[‚ö° Action]
    B -->|‚ùå No| D[üèÅ End]
    C --> D

    style A fill:#e1f5fe
    style B fill:#fff3e0
    style C fill:#e8f5e8
    style D fill:#fce4ec</textarea>

                <div class="controls-row">
                    <button class="btn" onclick="renderDiagram()" title="Ctrl+Enter">
                        ‚ö° Render
                    </button>

                    <div class="dropdown">
                        <button class="btn secondary" onclick="toggleDropdown('examples')">
                            üìö Examples
                        </button>
                        <div class="dropdown-content" id="examplesDropdown">
                            <div class="dropdown-item" onclick="loadExample('flowchart')">Flowchart</div>
                            <div class="dropdown-item" onclick="loadExample('sequence')">Sequence Diagram</div>
                            <div class="dropdown-item" onclick="loadExample('classDiagram')">Class Diagram</div>
                            <div class="dropdown-item" onclick="loadExample('gantt')">Gantt Chart</div>
                            <div class="dropdown-item" onclick="loadExample('stateDiagram')">State Diagram</div>
                            <div class="dropdown-item" onclick="loadExample('entityRelationship')">ER Diagram</div>
                        </div>
                    </div>

                    <button class="btn" onclick="showTutorial()" title="Mermaid Syntax Tutorial">
                        üìñ Tutorial
                    </button>

                    <div class="dropdown">
                        <button class="btn success" onclick="toggleDropdown('export')">
                            üíæ Export
                        </button>
                        <div class="dropdown-content" id="exportDropdown">
                            <div class="dropdown-item" onclick="exportDiagram('svg')">üìÑ SVG</div>
                            <div class="dropdown-item" onclick="exportDiagram('png')">üñºÔ∏è PNG</div>
                            <div class="dropdown-item" onclick="copyToClipboard('svg')">üìã Copy SVG</div>
                            <div class="dropdown-item" onclick="copyToClipboard('code')">üìù Copy Code</div>
                            <div class="dropdown-item" onclick="shareURL()">üîó Share URL</div>
                        </div>
                    </div>
                </div>

                <div class="controls-row">
                    <button class="btn small" onclick="importFile()">üìÅ Import</button>
                    <button class="btn small secondary" onclick="saveFile()">üíæ Save</button>
                    <button class="btn small" onclick="clearDiagram()">üóëÔ∏è Clear</button>
                    <button class="btn small" onclick="showShortcuts()">‚å®Ô∏è Shortcuts</button>
                </div>

                <div class="error-message" id="errorMessage"></div>
            </div>
        </div>

        <!-- Preview Panel -->
        <div class="panel preview-panel" id="previewPanel">
            <div class="panel-header">
                <h2>üëÅÔ∏è Live Preview</h2>
            </div>

            <div class="preview-content" id="previewContent">
                <div class="grid-overlay" id="gridOverlay"></div>

                <!-- Mermaid Diagram Container -->
                <div id="mermaidContainer"
                    style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; overflow: auto; background: white; border-radius: 10px;">
                    <div class="mermaid" id="mermaidDiagram" style="max-width: 100%; max-height: 100%;"></div>
                </div>

                <div class="loading-overlay" id="loadingOverlay">
                    <div class="spinner"></div>
                    <span>Rendering diagram...</span>
                </div>
            </div>

            <div class="preview-controls">
                <button class="control-btn" onclick="toggleFullscreen()" title="Fullscreen (F11)">‚õ∂</button>
                <button class="control-btn" onclick="zoomIn()" title="Zoom In (+)">+</button>
                <button class="control-btn" onclick="zoomOut()" title="Zoom Out (-)">‚àí</button>
                <button class="control-btn" onclick="resetZoom()" title="Reset Zoom (0)">‚Üª</button>
                <button class="control-btn" onclick="toggleGrid()" title="Toggle Grid" id="gridBtn">‚äû</button>
                <button class="control-btn" onclick="toggleSettings()" title="Settings">‚öôÔ∏è</button>
            </div>

            <div class="status-bar">
                <div class="zoom-info" id="zoomInfo">Zoom: 100%</div>
            </div>

            <!-- Settings Panel -->
            <div class="settings-panel" id="settingsPanel">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                    <h3 style="margin: 0; color: var(--primary-color);">‚öôÔ∏è Settings</h3>
                    <button onclick="toggleSettings()"
                        style="background: none; border: none; font-size: 18px; cursor: pointer; color: #666; padding: 4px;">‚úï</button>
                </div>
                <div class="settings-group">
                    <h4>üé® Theme</h4>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <div style="width: 24px; height: 24px; background: #2c3e50; border-radius: 50%; cursor: pointer; border: 2px solid transparent;"
                            onclick="changeTheme('default')" class="theme-btn active" data-theme="default"></div>
                        <div style="width: 24px; height: 24px; background: #3498db; border-radius: 50%; cursor: pointer; border: 2px solid transparent;"
                            onclick="changeTheme('blue')" class="theme-btn" data-theme="blue"></div>
                        <div style="width: 24px; height: 24px; background: #e74c3c; border-radius: 50%; cursor: pointer; border: 2px solid transparent;"
                            onclick="changeTheme('red')" class="theme-btn" data-theme="red"></div>
                        <div style="width: 24px; height: 24px; background: #2ecc71; border-radius: 50%; cursor: pointer; border: 2px solid transparent;"
                            onclick="changeTheme('green')" class="theme-btn" data-theme="green"></div>
                    </div>
                </div>

                <div class="settings-group">
                    <h4>üìê Layout & Structure</h4>
                    <div class="setting-item">
                        <label>Direction:</label>
                        <select id="diagramDirection" onchange="updateLayoutSettings()">
                            <option value="TD">Top to Bottom</option>
                            <option value="LR">Left to Right</option>
                            <option value="BT">Bottom to Top</option>
                            <option value="RL">Right to Left</option>
                        </select>
                    </div>
                    <div class="setting-item">
                        <label>Node Spacing:</label>
                        <input type="range" min="30" max="100" value="50" id="nodeSpacing"
                            onchange="updateLayoutSettings()" oninput="updateRangeDisplay('nodeSpacing', 'px')">
                        <span id="nodeSpacingValue">50px</span>
                    </div>
                    <div class="setting-item">
                        <label>Rank Spacing:</label>
                        <input type="range" min="50" max="150" value="100" id="rankSpacing"
                            onchange="updateLayoutSettings()" oninput="updateRangeDisplay('rankSpacing', 'px')">
                        <span id="rankSpacingValue">100px</span>
                    </div>
                    <div class="setting-item">
                        <label>Curve Style:</label>
                        <select id="curveStyle" onchange="updateLayoutSettings()">
                            <option value="basis">Curved</option>
                            <option value="linear">Straight</option>
                            <option value="step">Stepped</option>
                            <option value="cardinal">Cardinal</option>
                        </select>
                    </div>
                </div>

                <div class="settings-group">
                    <h4>üé® Appearance</h4>
                    <div class="setting-item">
                        <label>Font Size:</label>
                        <select id="fontSize" onchange="updateAppearanceSettings()">
                            <option value="12">Small (12px)</option>
                            <option value="14" selected>Medium (14px)</option>
                            <option value="16">Large (16px)</option>
                            <option value="18">Extra Large (18px)</option>
                        </select>
                    </div>
                    <div class="setting-item">
                        <label>Line Width:</label>
                        <input type="range" min="1" max="5" value="2" id="lineWidth" onchange="updateAppearanceSettings()"
                            oninput="updateRangeDisplay('lineWidth', 'px')">
                        <span id="lineWidthValue">2px</span>
                    </div>
                    <div class="setting-item">
                        <label>Node Border:</label>
                        <select id="nodeBorder" onchange="updateAppearanceSettings()">
                            <option value="1">Thin (1px)</option>
                            <option value="2" selected>Medium (2px)</option>
                            <option value="3">Thick (3px)</option>
                        </select>
                    </div>
                    <div class="setting-item">
                        <label>Corner Radius:</label>
                        <input type="range" min="0" max="15" value="5" id="cornerRadius"
                            onchange="updateAppearanceSettings()" oninput="updateRangeDisplay('cornerRadius', 'px')">
                        <span id="cornerRadiusValue">5px</span>
                    </div>
                </div>

                <div class="settings-group">
                    <h4>üì§ Export Settings</h4>
                    <div class="setting-item">
                        <label>PNG Quality:</label>
                        <select id="pngQuality">
                            <option value="1">Standard (1x)</option>
                            <option value="2" selected>High (2x)</option>
                            <option value="3">Very High (3x)</option>
                            <option value="4">Ultra (4x)</option>
                        </select>
                    </div>
                    <div class="setting-item">
                        <label>Background:</label>
                        <select id="exportBackground">
                            <option value="white">White</option>
                            <option value="transparent">Transparent</option>
                        </select>
                    </div>
                    <div class="setting-item">
                        <label>Format:</label>
                        <select id="exportFormat">
                            <option value="png">PNG Image</option>
                            <option value="svg">SVG Vector</option>
                        </select>
                    </div>
                    <div class="setting-item">
                        <label>Padding:</label>
                        <select id="exportPadding">
                            <option value="10">Minimal (10px)</option>
                            <option value="20" selected>Standard (20px)</option>
                            <option value="40">Generous (40px)</option>
                            <option value="60">Extra (60px)</option>
                        </select>
                    </div>
                    <div class="setting-item">
                        <label>Auto-fit Content:</label>
                        <select id="autoFitContent">
                            <option value="true" selected>Yes</option>
                            <option value="false">No</option>
                        </select>
                    </div>
                </div>

                <div style="display: flex; gap: 8px; margin-top: 16px;">
                    <button class="btn small" onclick="quickExport()" style="flex: 1;">üì§ Quick Export</button>
                    <button class="btn small secondary" onclick="resetSettings()">üîÑ Reset</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Success Message Toast -->
    <div class="success-message" id="successMessage"></div>

    <!-- Keyboard Shortcuts Help -->
    <div class="shortcuts-help" id="shortcutsHelp">
        <h3>‚å®Ô∏è Keyboard Shortcuts</h3>
        <div class="shortcut-item">
            <span>Render Diagram</span>
            <span class="shortcut-key">Ctrl + Enter</span>
        </div>
        <div class="shortcut-item">
            <span>Save Diagram</span>
            <span class="shortcut-key">Ctrl + S</span>
        </div>
        <div class="shortcut-item">
            <span>Toggle Fullscreen</span>
            <span class="shortcut-key">F11</span>
        </div>
        <div class="shortcut-item">
            <span>Zoom In</span>
            <span class="shortcut-key">Ctrl + Plus</span>
        </div>
        <div class="shortcut-item">
            <span>Zoom Out</span>
            <span class="shortcut-key">Ctrl + Minus</span>
        </div>
        <div class="shortcut-item">
            <span>Reset Zoom</span>
            <span class="shortcut-key">Ctrl + 0</span>
        </div>
        <div class="shortcut-item">
            <span>Toggle Grid</span>
            <span class="shortcut-key">Ctrl + G</span>
        </div>
        <button class="btn" onclick="hideShortcuts()" style="margin-top: 16px; width: 100%;">Close</button>
    </div>

    <!-- Hidden file input -->
    <input type="file" id="fileInput" accept=".mmd,.txt,.md" style="display: none;" onchange="handleFileImport(event)">

    <!-- Tutorial Modal -->
    <div class="tutorial-modal" id="tutorialModal">
        <div class="tutorial-content">
            <div class="tutorial-header">
                <h2>üìñ Mermaid Syntax Tutorial</h2>
                <button onclick="hideTutorial()" class="tutorial-close">‚úï</button>
            </div>

            <div class="tutorial-links">
                <h3>üìö Official Resources</h3>
                <div class="link-grid">
                    <a href="https://mermaid.js.org/intro/syntax-reference.html" target="_blank" class="tutorial-link">
                        üìã Official Syntax Reference
                    </a>
                    <a href="https://mermaid.js.org/intro/" target="_blank" class="tutorial-link">
                        üöÄ Getting Started Guide
                    </a>
                    <a href="https://mermaid.live/" target="_blank" class="tutorial-link">
                        üîß Live Editor
                    </a>
                    <a href="https://github.com/mermaid-js/mermaid" target="_blank" class="tutorial-link">
                        üíª GitHub Repository
                    </a>
                </div>
            </div>

            <div class="tutorial-tabs">
                <div class="tab-buttons">
                    <button class="tab-btn active" onclick="showTab('flowchart')">Flowchart</button>
                    <button class="tab-btn" onclick="showTab('sequence')">Sequence</button>
                    <button class="tab-btn" onclick="showTab('class')">Class</button>
                    <button class="tab-btn" onclick="showTab('er')">ER Diagram</button>
                    <button class="tab-btn" onclick="showTab('gantt')">Gantt</button>
                    <button class="tab-btn" onclick="showTab('state')">State</button>
                </div>

                <div class="tab-content">
                    <!-- Flowchart Tab -->
                    <div class="tab-panel active" id="flowchart-tab">
                        <h3>üîÑ Flowchart Syntax</h3>
                        <div class="syntax-section">
                            <h4>Basic Structure:</h4>
                            <pre><code>graph TD
    A[Start] --> B{Decision}
    B -->|Yes| C[Action 1]
    B -->|No| D[Action 2]
    C --> E[End]
    D --> E</code></pre>
                            <button onclick="copyToEditor('flowchart-basic')" class="copy-btn">üìã Copy to
                                Editor</button>
                        </div>

                        <div class="syntax-section">
                            <h4>Node Shapes:</h4>
                            <pre><code>graph LR
    A[Rectangle] --> B(Round edges)
    B --> C((Circle))
    C --> D{Diamond}
    D --> E>Flag]
    E --> F[/Parallelogram/]</code></pre>
                            <button onclick="copyToEditor('flowchart-shapes')" class="copy-btn">üìã Copy to
                                Editor</button>
                        </div>

                        <div class="syntax-section">
                            <h4>Styling:</h4>
                            <pre><code>graph TD
    A[Start] --> B[Process]
    B --> C[End]

    style A fill:#e1f5fe
    style B fill:#fff3e0
    style C fill:#e8f5e8</code></pre>
                            <button onclick="copyToEditor('flowchart-styling')" class="copy-btn">üìã Copy to
                                Editor</button>
                        </div>
                    </div>

                    <!-- Sequence Tab -->
                    <div class="tab-panel" id="sequence-tab">
                        <h3>üìû Sequence Diagram Syntax</h3>
                        <div class="syntax-section">
                            <h4>Basic Structure:</h4>
                            <pre><code>sequenceDiagram
    participant A as Alice
    participant B as Bob
    A->>B: Hello Bob!
    B-->>A: Hello Alice!</code></pre>
                            <button onclick="copyToEditor('sequence-basic')" class="copy-btn">üìã Copy to Editor</button>
                        </div>

                        <div class="syntax-section">
                            <h4>Advanced Features:</h4>
                            <pre><code>sequenceDiagram
    participant U as User
    participant S as System
    participant D as Database

    U->>S: Login Request
    activate S
    S->>D: Validate User
    D-->>S: User Valid
    S-->>U: Login Success
    deactivate S

    Note over U,S: User is now logged in</code></pre>
                            <button onclick="copyToEditor('sequence-advanced')" class="copy-btn">üìã Copy to
                                Editor</button>
                        </div>
                    </div>

                    <!-- Class Tab -->
                    <div class="tab-panel" id="class-tab">
                        <h3>üèóÔ∏è Class Diagram Syntax</h3>
                        <div class="syntax-section">
                            <h4>Basic Structure:</h4>
                            <pre><code>classDiagram
    class Animal {
        +String name
        +int age
        +makeSound()
    }

    class Dog {
        +String breed
        +bark()
    }

    Animal <|-- Dog</code></pre>
                            <button onclick="copyToEditor('class-basic')" class="copy-btn">üìã Copy to Editor</button>
                        </div>

                        <div class="syntax-section">
                            <h4>Visibility & Relationships:</h4>
                            <pre><code>classDiagram
    class BankAccount {
        +String owner
        +Decimal balance
        -String accountNumber
        #validateTransaction()
        +deposit(amount)
        +withdraw(amount)
    }

    class SavingsAccount {
        +Float interestRate
        +calculateInterest()
    }

    BankAccount <|-- SavingsAccount</code></pre>
                            <button onclick="copyToEditor('class-advanced')" class="copy-btn">üìã Copy to Editor</button>
                        </div>
                    </div>

                    <!-- ER Tab -->
                    <div class="tab-panel" id="er-tab">
                        <h3>üóÑÔ∏è ER Diagram Syntax</h3>
                        <div class="syntax-section">
                            <h4>Basic Structure:</h4>
                            <pre><code>erDiagram
    CUSTOMER ||--o{ ORDER : places
    ORDER ||--|{ LINE-ITEM : contains
    PRODUCT ||--o{ LINE-ITEM : "ordered in"</code></pre>
                            <button onclick="copyToEditor('er-basic')" class="copy-btn">üìã Copy to Editor</button>
                        </div>

                        <div class="syntax-section">
                            <h4>With Attributes:</h4>
                            <pre><code>erDiagram
    CUSTOMER {
        int customer_id PK
        string first_name
        string last_name
        string email
    }

    ORDER {
        int order_id PK
        int customer_id FK
        date order_date
        decimal total_amount
    }

    CUSTOMER ||--o{ ORDER : places</code></pre>
                            <button onclick="copyToEditor('er-advanced')" class="copy-btn">üìã Copy to Editor</button>
                        </div>
                    </div>

                    <!-- Gantt Tab -->
                    <div class="tab-panel" id="gantt-tab">
                        <h3>üìÖ Gantt Chart Syntax</h3>
                        <div class="syntax-section">
                            <h4>Basic Structure:</h4>
                            <pre><code>gantt
    title Project Timeline
    dateFormat YYYY-MM-DD

    section Planning
    Requirements    :done, req, 2024-01-01, 2024-01-10
    Design         :active, design, 2024-01-08, 2024-01-20

    section Development
    Frontend       :frontend, 2024-01-15, 30d
    Backend        :backend, 2024-01-20, 25d</code></pre>
                            <button onclick="copyToEditor('gantt-basic')" class="copy-btn">üìã Copy to Editor</button>
                        </div>
                    </div>

                    <!-- State Tab -->
                    <div class="tab-panel" id="state-tab">
                        <h3>üîÑ State Diagram Syntax</h3>
                        <div class="syntax-section">
                            <h4>Basic Structure:</h4>
                            <pre><code>stateDiagram-v2
    [*] --> Idle
    Idle --> Running : start
    Running --> Paused : pause
    Running --> Stopped : stop
    Paused --> Running : resume
    Paused --> Stopped : stop
    Stopped --> Idle : reset</code></pre>
                            <button onclick="copyToEditor('state-basic')" class="copy-btn">üìã Copy to Editor</button>
                        </div>

                        <div class="syntax-section">
                            <h4>Composite States:</h4>
                            <pre><code>stateDiagram-v2
    [*] --> Active

    state Active {
        [*] --> Processing
        Processing --> Validating
        Validating --> Processing
        Processing --> Complete
    }

    Active --> Inactive : timeout
    Inactive --> Active : restart</code></pre>
                            <button onclick="copyToEditor('state-advanced')" class="copy-btn">üìã Copy to Editor</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== GLOBAL STATE =====
        let currentScale = 1;
        let panOffset = { x: 0, y: 0 };
        let isGridVisible = false;
        let isFullscreen = false;
        let autoSaveTimer = null;
        let currentDiagramHash = '';
        let mermaidInitialized = false;

        // Mouse interaction state
        let isDragging = false;
        let lastMousePos = { x: 0, y: 0 };
        let dragStartPos = { x: 0, y: 0 };

        // Zoom limits
        const MIN_ZOOM = 0.1;
        const MAX_ZOOM = 5.0;
        const ZOOM_STEP = 1.2;

























        // ===== INITIALIZATION =====
        window.addEventListener('DOMContentLoaded', function () {
            initializeApp();
        });

        function initializeApp() {
            // Initialize Mermaid
            initializeMermaid();

            // Load saved state
            loadFromStorage();

            // Setup event listeners
            setupEventListeners();

            // Initialize appearance settings
            initializeAppearanceSettings();

            // Auto-render initial diagram if there's content
            const code = document.getElementById('code').value.trim();
            if (code) {
                setTimeout(() => {
                    renderDiagram();
                }, 500);
            }

            // Show welcome message
            showSuccess('Welcome to MermaidEase Pro! üéâ‚ú®');
        }

        function initializeMermaid() {
            if (mermaidInitialized) return;

            try {
                mermaid.initialize({
                    startOnLoad: false,
                    theme: 'default',
                    securityLevel: 'loose',
                    fontFamily: 'Segoe UI, Tahoma, Geneva, Verdana, sans-serif',
                    flowchart: {
                        useMaxWidth: true,
                        htmlLabels: true,
                        curve: 'basis'
                    },
                    sequence: {
                        useMaxWidth: true,
                        wrap: true
                    },
                    gantt: {
                        useMaxWidth: true
                    },
                    class: {
                        useMaxWidth: true
                    },
                    state: {
                        useMaxWidth: true
                    },
                    er: {
                        useMaxWidth: true
                    }
                });
                mermaidInitialized = true;
                console.log('Mermaid initialized successfully');
            } catch (error) {
                console.error('Failed to initialize Mermaid:', error);
                showError('Failed to initialize Mermaid: ' + error.message);
            }
        }

        function setupEventListeners() {
            const codeEditor = document.getElementById('code');

            // Auto-save on code change
            codeEditor.addEventListener('input', debounce(autoSave, 2000));

            // Keyboard shortcuts
            document.addEventListener('keydown', handleKeyboardShortcuts);

            // Close dropdowns when clicking outside
            document.addEventListener('click', closeDropdowns);

            // Tutorial modal event listeners
            document.addEventListener('keydown', function (e) {
                if (e.key === 'Escape') {
                    hideTutorial();
                }
            });

            // Close tutorial when clicking outside content
            const tutorialModal = document.getElementById('tutorialModal');
            if (tutorialModal) {
                tutorialModal.addEventListener('click', function (e) {
                    if (e.target === this) {
                        hideTutorial();
                    }
                });
            }

            // Setup mouse interaction for preview panel
            setupMouseInteractions();
        }

        function setupMouseInteractions() {
            const previewContent = document.getElementById('previewContent');
            const mermaidContainer = document.getElementById('mermaidContainer');

            if (!previewContent || !mermaidContainer) return;

            // Mouse wheel zoom
            previewContent.addEventListener('wheel', handleMouseWheel, { passive: false });

            // Mouse drag for panning
            mermaidContainer.addEventListener('mousedown', handleMouseDown);
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);

            // Prevent context menu on right click in preview area
            previewContent.addEventListener('contextmenu', (e) => e.preventDefault());

            // Prevent text selection during drag
            mermaidContainer.style.userSelect = 'none';
            mermaidContainer.style.webkitUserSelect = 'none';
        }

        // ===== AUTO-SAVE & STORAGE =====
        function autoSave() {
            const code = document.getElementById('code').value;
            if (code.trim()) {
                localStorage.setItem('mermaid_code', code);
                updateAutoSaveIndicator('saved');
                setTimeout(() => updateAutoSaveIndicator(''), 2000);
            }
        }

        function updateAutoSaveIndicator(state) {
            const indicator = document.getElementById('autoSaveIndicator');
            const text = document.getElementById('autoSaveText');

            indicator.className = `auto-save-indicator ${state}`;

            switch (state) {
                case 'saving':
                    text.textContent = 'Saving...';
                    break;
                case 'saved':
                    text.textContent = 'Saved ‚úì';
                    break;
                default:
                    text.textContent = 'Auto-save';
            }
        }

        function loadFromStorage() {
            const savedCode = localStorage.getItem('mermaid_code');

            if (savedCode) {
                document.getElementById('code').value = savedCode;
            }
        }

        function saveToStorage() {
            const code = document.getElementById('code').value;
            localStorage.setItem('mermaid_code', code);
        }

        function renderDiagram() {
            const code = document.getElementById('code').value.trim();

            if (!code) {
                showError('Please enter some Mermaid code to render.');
                return;
            }

            // Show loading
            showLoading(true);
            clearError();

            try {
                // Initialize Mermaid if not already done
                if (!mermaidInitialized) {
                    initializeMermaid();
                }

                // Generate unique ID for this diagram
                const diagramId = 'mermaid-diagram-' + Date.now();

                // Clear previous diagram
                const mermaidContainer = document.getElementById('mermaidDiagram');
                mermaidContainer.innerHTML = '';
                mermaidContainer.removeAttribute('data-processed');

                // Render the diagram
                mermaid.render(diagramId, code).then(({ svg, bindFunctions }) => {
                    // Insert the SVG
                    mermaidContainer.innerHTML = svg;

                    // Bind any interactive functions
                    if (bindFunctions) {
                        bindFunctions(mermaidContainer);
                    }

                    // Apply current zoom and pan
                    applyTransform();

                    // Hide loading
                    showLoading(false);

                    // Update hash to track changes
                    currentDiagramHash = generateHash(code);

                    showSuccess('Diagram rendered successfully! üéâ');

                }).catch(error => {
                    console.error('Mermaid render error:', error);
                    showLoading(false);
                    showError('Failed to render diagram: ' + (error.message || 'Invalid syntax'));
                });

            } catch (error) {
                console.error('Mermaid error:', error);
                showLoading(false);
                showError('Failed to render diagram: ' + (error.message || 'Invalid syntax'));
            }
        }

        // ===== KEYBOARD SHORTCUTS =====
        function handleKeyboardShortcuts(e) {
            // Don't trigger shortcuts when typing in inputs
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                if (e.ctrlKey && e.key === 'Enter') {
                    e.preventDefault();
                    renderDiagram();
                }
                return;
            }

            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 'Enter':
                        e.preventDefault();
                        renderDiagram();
                        break;
                    case 's':
                        e.preventDefault();
                        saveFile();
                        break;
                    case 'g':
                        e.preventDefault();
                        toggleGrid();
                        break;
                    case '=':
                    case '+':
                        e.preventDefault();
                        zoomIn();
                        break;
                    case '-':
                        e.preventDefault();
                        zoomOut();
                        break;
                    case '0':
                        e.preventDefault();
                        resetZoom();
                        break;
                }
            } else {
                switch (e.key) {
                    case 'F11':
                        e.preventDefault();
                        toggleFullscreen();
                        break;
                    case 'Escape':
                        hideShortcuts();
                        closeDropdowns();
                        break;
                }
            }
        }

        // ===== MOUSE INTERACTION HANDLERS =====
        function handleMouseWheel(e) {
            e.preventDefault();

            const delta = e.deltaY > 0 ? -1 : 1;
            const zoomFactor = Math.pow(ZOOM_STEP, delta * 0.1);
            const newScale = currentScale * zoomFactor;

            // Apply zoom limits
            if (newScale >= MIN_ZOOM && newScale <= MAX_ZOOM) {
                // Get mouse position relative to the container
                const rect = e.currentTarget.getBoundingClientRect();
                const mouseX = e.clientX - rect.left - rect.width / 2;
                const mouseY = e.clientY - rect.top - rect.height / 2;

                // Adjust pan offset to zoom towards mouse position
                panOffset.x = mouseX - (mouseX - panOffset.x) * zoomFactor;
                panOffset.y = mouseY - (mouseY - panOffset.y) * zoomFactor;

                currentScale = newScale;
                applyTransform();
            }
        }

        function handleMouseDown(e) {
            if (e.button === 0) { // Left mouse button
                isDragging = true;
                dragStartPos = { x: e.clientX, y: e.clientY };
                lastMousePos = { x: e.clientX, y: e.clientY };

                // Change cursor to grabbing
                e.currentTarget.style.cursor = 'grabbing';
                e.preventDefault();
            }
        }

        function handleMouseMove(e) {
            if (isDragging) {
                const deltaX = e.clientX - lastMousePos.x;
                const deltaY = e.clientY - lastMousePos.y;

                panOffset.x += deltaX;
                panOffset.y += deltaY;

                lastMousePos = { x: e.clientX, y: e.clientY };
                applyTransform();
                e.preventDefault();
            }
        }

        function handleMouseUp(e) {
            if (isDragging) {
                isDragging = false;

                // Reset cursor
                const mermaidContainer = document.getElementById('mermaidContainer');
                if (mermaidContainer) {
                    mermaidContainer.style.cursor = currentScale > 1 ? 'grab' : 'default';
                }
            }
        }

        // ===== ZOOM AND VIEW CONTROLS =====
        function zoomIn() {
            if (currentScale < MAX_ZOOM) {
                currentScale *= ZOOM_STEP;
                applyTransform();
                updateCursor();
            }
        }

        function zoomOut() {
            if (currentScale > MIN_ZOOM) {
                currentScale /= ZOOM_STEP;
                applyTransform();
                updateCursor();
            }
        }

        function resetZoom() {
            currentScale = 1;
            panOffset = { x: 0, y: 0 };
            applyTransform();
            updateCursor();
        }

        function updateCursor() {
            const mermaidContainer = document.getElementById('mermaidContainer');
            if (mermaidContainer) {
                mermaidContainer.style.cursor = currentScale > 1 ? 'grab' : 'default';
            }
        }

        function updateZoomInfo() {
            const zoomInfo = document.getElementById('zoomInfo');
            if (zoomInfo) {
                zoomInfo.textContent = `Zoom: ${Math.round(currentScale * 100)}%`;
            }
        }

        function applyTransform() {
            const svg = document.querySelector('#mermaidContainer svg');
            if (svg) {
                svg.style.transform = `scale(${currentScale}) translate(${panOffset.x / currentScale}px, ${panOffset.y / currentScale}px)`;
                svg.style.transformOrigin = 'center center';
                updateZoomInfo();
            }
        }

        // ===== GRID AND FULLSCREEN =====
        function toggleGrid() {
            isGridVisible = !isGridVisible;
            const gridOverlay = document.getElementById('gridOverlay');
            const gridBtn = document.getElementById('gridBtn');

            if (isGridVisible) {
                gridOverlay.classList.add('active');
                gridBtn.classList.add('active');
                showSuccess('Grid enabled! üìê');
            } else {
                gridOverlay.classList.remove('active');
                gridBtn.classList.remove('active');
                showSuccess('Grid disabled! üìê');
            }
        }

        function toggleFullscreen() {
            const previewPanel = document.getElementById('previewPanel');
            isFullscreen = !isFullscreen;

            if (isFullscreen) {
                previewPanel.classList.add('fullscreen');
                showSuccess('Fullscreen mode enabled! Press F11 or Escape to exit.');
            } else {
                previewPanel.classList.remove('fullscreen');
                showSuccess('Fullscreen mode disabled!');
            }
        }

        // ===== SETTINGS AND UTILITIES =====
        function toggleSettings() {
            const settingsPanel = document.getElementById('settingsPanel');
            settingsPanel.classList.toggle('active');
        }

        function showLoading(show) {
            const loadingOverlay = document.getElementById('loadingOverlay');
            if (show) {
                loadingOverlay.classList.add('active');
            } else {
                loadingOverlay.classList.remove('active');
            }
        }

        // ===== ERROR AND SUCCESS MESSAGES =====
        function showError(message) {
            const errorElement = document.getElementById('errorMessage');
            if (errorElement) {
                errorElement.textContent = message;
                errorElement.classList.add('active');
                setTimeout(() => {
                    errorElement.classList.remove('active');
                }, 5000);
            }
        }

        function clearError() {
            const errorElement = document.getElementById('errorMessage');
            if (errorElement) {
                errorElement.classList.remove('active');
            }
        }

        function showSuccess(message) {
            const successElement = document.getElementById('successMessage');
            if (successElement) {
                successElement.textContent = message;
                successElement.classList.add('show');
                setTimeout(() => {
                    successElement.classList.remove('show');
                }, 3000);
            }
        }

        // ===== FILE OPERATIONS =====
        function saveFile() {
            const code = document.getElementById('code').value;
            const blob = new Blob([code], { type: 'text/plain;charset=utf-8' });
            saveAs(blob, 'diagram.mmd');
            showSuccess('File saved successfully! üíæ');
        }

        function loadFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.mmd,.txt';
            input.onchange = function (e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        document.getElementById('code').value = e.target.result;
                        renderDiagram();
                        showSuccess('File loaded successfully! üìÇ');
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        // ===== UTILITY FUNCTIONS =====
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function generateHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32bit integer
            }
            return hash.toString();
        }

        function autoSave() {
            saveToStorage();
            clearTimeout(autoSaveTimer);
            autoSaveTimer = setTimeout(() => {
                showSuccess('Auto-saved! üíæ');
            }, 500);
        }

        function closeDropdowns() {
            // Close any open dropdowns
            document.querySelectorAll('.dropdown.active').forEach(dropdown => {
                dropdown.classList.remove('active');
            });
        }

        // ===== SHORTCUTS AND HELP =====
        function showShortcuts() {
            document.getElementById('shortcutsHelp').classList.add('active');
        }

        function hideShortcuts() {
            document.getElementById('shortcutsHelp').classList.remove('active');
        }

        // ===== TUTORIAL FUNCTIONS =====
        function showTutorial() {
            document.getElementById('tutorialModal').classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function hideTutorial() {
            document.getElementById('tutorialModal').classList.remove('active');
            document.body.style.overflow = '';
        }

        function showTab(tabName) {
            // Remove active class from all tabs and panels
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));

            // Add active class to selected tab and panel
            document.querySelector(`[onclick="showTab('${tabName}')"]`).classList.add('active');
            document.getElementById(`${tabName}-tab`).classList.add('active');
        }

        function copyToEditor(exampleType) {
            const examples = {
                'flowchart-basic': `graph TD
    A[Start] --> B{Decision}
    B -->|Yes| C[Action 1]
    B -->|No| D[Action 2]
    C --> E[End]
    D --> E`,

                'flowchart-shapes': `graph LR
    A[Rectangle] --> B(Round edges)
    B --> C((Circle))
    C --> D{Diamond}
    D --> E>Flag]
    E --> F[/Parallelogram/]`,

                'flowchart-styling': `graph TD
    A[Start] --> B[Process]
    B --> C[End]

    style A fill:#e1f5fe
    style B fill:#fff3e0
    style C fill:#e8f5e8`,

                'sequence-basic': `sequenceDiagram
    participant A as Alice
    participant B as Bob
    A->>B: Hello Bob!
    B-->>A: Hello Alice!`,

                'sequence-advanced': `sequenceDiagram
    participant U as User
    participant S as System
    participant D as Database

    U->>S: Login Request
    activate S
    S->>D: Validate User
    D-->>S: User Valid
    S-->>U: Login Success
    deactivate S

    Note over U,S: User is now logged in`,

                'class-basic': `classDiagram
    class Animal {
        +String name
        +int age
        +makeSound()
    }

    class Dog {
        +String breed
        +bark()
    }

    Animal <|-- Dog`,

                'class-advanced': `classDiagram
    class BankAccount {
        +String owner
        +Decimal balance
        -String accountNumber
        #validateTransaction()
        +deposit(amount)
        +withdraw(amount)
    }

    class SavingsAccount {
        +Float interestRate
        +calculateInterest()
    }

    BankAccount <|-- SavingsAccount`,

                'er-basic': `erDiagram
    CUSTOMER ||--o{ ORDER : places
    ORDER ||--|{ LINE-ITEM : contains
    PRODUCT ||--o{ LINE-ITEM : "ordered in"`,

                'er-advanced': `erDiagram
    CUSTOMER {
        int customer_id PK
        string first_name
        string last_name
        string email
    }

    ORDER {
        int order_id PK
        int customer_id FK
        date order_date
        decimal total_amount
    }

    CUSTOMER ||--o{ ORDER : places`,

                'gantt-basic': `gantt
    title Project Timeline
    dateFormat YYYY-MM-DD

    section Planning
    Requirements    :done, req, 2024-01-01, 2024-01-10
    Design         :active, design, 2024-01-08, 2024-01-20

    section Development
    Frontend       :frontend, 2024-01-15, 30d
    Backend        :backend, 2024-01-20, 25d`,

                'state-basic': `stateDiagram-v2
    [*] --> Idle
    Idle --> Running : start
    Running --> Paused : pause
    Running --> Stopped : stop
    Paused --> Running : resume
    Paused --> Stopped : stop
    Stopped --> Idle : reset`,

                'state-advanced': `stateDiagram-v2
    [*] --> Active

    state Active {
        [*] --> Processing
        Processing --> Validating
        Validating --> Processing
        Processing --> Complete
    }

    Active --> Inactive : timeout
    Inactive --> Active : restart`
            };

            const code = examples[exampleType];
            if (code) {
                document.getElementById('code').value = code;
                hideTutorial();
                renderDiagram();
                showSuccess('Example copied to editor! üìã');
            }
        }

        function toggleDropdown(id) {
            // Prevent event bubbling
            event.stopPropagation();

            const dropdown = document.getElementById(id + 'Dropdown');

            if (!dropdown) {
                console.warn(`Dropdown with id "${id}Dropdown" not found`);
                return;
            }

            const isVisible = dropdown.classList.contains('show');

            // Close all dropdowns first
            closeDropdowns();

            // Toggle the requested dropdown
            if (!isVisible) {
                dropdown.classList.add('show');

                // Add click outside listener to close dropdown
                setTimeout(() => {
                    document.addEventListener('click', function closeOnClickOutside(e) {
                        if (!dropdown.contains(e.target) && !e.target.closest('.dropdown')) {
                            dropdown.classList.remove('show');
                            document.removeEventListener('click', closeOnClickOutside);
                        }
                    });
                }, 10);
            }
        }

        // ===== UI CONTROLS =====
        function toggleDropdown(id) {
            // Prevent event bubbling
            event.stopPropagation();

            const dropdown = document.getElementById(id + 'Dropdown');

            if (!dropdown) {
                console.warn(`Dropdown with id "${id}Dropdown" not found`);
                return;
            }

            const isVisible = dropdown.classList.contains('show');

            // Close all dropdowns first
            closeDropdowns();

            // Toggle the requested dropdown
            if (!isVisible) {
                // Calculate optimal position before showing
                positionDropdown(dropdown);

                dropdown.classList.add('show');

                // Add click outside listener to close dropdown
                setTimeout(() => {
                    document.addEventListener('click', function closeOnClickOutside(e) {
                        if (!dropdown.contains(e.target) && !e.target.closest('.dropdown')) {
                            dropdown.classList.remove('show');
                            document.removeEventListener('click', closeOnClickOutside);
                        }
                    });
                }, 10);
            }
        }

        function positionDropdown(dropdown) {
            // Reset positioning classes
            dropdown.classList.remove('dropdown-up', 'dropdown-right');

            // Get dropdown button and viewport dimensions
            const button = dropdown.parentElement.querySelector('button');
            const buttonRect = button.getBoundingClientRect();
            const viewportHeight = window.innerHeight;
            const viewportWidth = window.innerWidth;

            // Temporarily show dropdown to measure its dimensions
            dropdown.style.visibility = 'hidden';
            dropdown.style.display = 'block';
            const dropdownRect = dropdown.getBoundingClientRect();
            dropdown.style.display = '';
            dropdown.style.visibility = '';

            // Check if dropdown would be cut off at bottom
            const spaceBelow = viewportHeight - buttonRect.bottom;
            const spaceAbove = buttonRect.top;

            if (spaceBelow < dropdownRect.height && spaceAbove > dropdownRect.height) {
                dropdown.classList.add('dropdown-up');
            }

            // Check if dropdown would be cut off at right
            const spaceRight = viewportWidth - buttonRect.left;
            if (spaceRight < dropdownRect.width) {
                dropdown.classList.add('dropdown-right');
            }
        }

        function closeDropdowns() {
            document.querySelectorAll('.dropdown-content').forEach(dropdown => {
                dropdown.classList.remove('show');
            });
        }

        function toggleFullscreen() {
            const panel = document.getElementById('previewPanel');
            isFullscreen = !isFullscreen;

            if (isFullscreen) {
                panel.classList.add('fullscreen');
                document.body.style.overflow = 'hidden';
            } else {
                panel.classList.remove('fullscreen');
                document.body.style.overflow = '';
            }
        }

        function toggleGrid() {
            isGridVisible = !isGridVisible;
            const grid = document.getElementById('gridOverlay');
            const btn = document.getElementById('gridBtn');

            if (isGridVisible) {
                grid.classList.add('active');
                btn.classList.add('active');
            } else {
                grid.classList.remove('active');
                btn.classList.remove('active');
            }
        }

        function showShortcuts() {
            document.getElementById('shortcutsHelp').classList.add('active');
        }

        function hideShortcuts() {
            document.getElementById('shortcutsHelp').classList.remove('active');
        }



        // ===== EXAMPLES =====
        function loadExample(type) {
            const examples = {
                flowchart: `graph TD
    A[üöÄ Start Project] --> B{üìã Requirements Clear?}
    B -->|‚úÖ Yes| C[‚ö° Begin Development]
    B -->|‚ùå No| D[üìù Gather Requirements]
    D --> B
    C --> E[üß™ Testing Phase]
    E --> F{üêõ Bugs Found?}
    F -->|‚úÖ Yes| G[üîß Fix Issues]
    F -->|‚ùå No| H[üöÄ Deploy]
    G --> E
    H --> I[üìä Monitor & Maintain]`,

                sequence: `sequenceDiagram
    participant üë§ User as User
    participant üíª App as Application
    participant üóÑÔ∏è DB as Database
    participant üìß Email as Email Service

    üë§ User->>üíª App: Submit Registration
    üíª App->>üóÑÔ∏è DB: Check if user exists
    üóÑÔ∏è DB-->>üíª App: User not found
    üíª App->>üóÑÔ∏è DB: Create new user
    üóÑÔ∏è DB-->>üíª App: User created
    üíª App->>üìß Email: Send welcome email
    üìß Email-->>üíª App: Email sent
    üíª App-->>üë§ User: Registration successful`,

                classDiagram: `classDiagram
    class Animal {
        +String name
        +int age
        +String species
        +makeSound()
        +eat()
        +sleep()
    }

    class Dog {
        +String breed
        +boolean isGoodBoy
        +String favoritetoy
        +bark()
        +fetch()
        +wagTail()
    }

    class Cat {
        +String color
        +int livesRemaining
        +boolean isIndoor
        +meow()
        +scratch()
        +purr()
    }

    Animal <|-- Dog
    Animal <|-- Cat`,

                gantt: `gantt
    title üöÄ Project Development Timeline
    dateFormat YYYY-MM-DD
    section üìã Planning
    Requirements Analysis    :done, req, 2024-01-01, 2024-01-10
    System Design          :done, design, 2024-01-08, 2024-01-20

    section üíª Development
    Frontend Development    :active, frontend, 2024-01-15, 2024-02-28
    Backend Development     :backend, 2024-01-20, 2024-03-15
    Database Setup         :db, 2024-01-25, 2024-02-10

    section üß™ Testing
    Unit Testing           :testing, after frontend, 10d
    Integration Testing    :integration, after backend, 15d
    User Acceptance Testing :uat, after integration, 10d

    section üöÄ Deployment
    Production Setup       :deploy, after uat, 5d
    Go Live               :milestone, golive, after deploy, 1d`,

                stateDiagram: `stateDiagram-v2
    [*] --> Idle
    Idle --> Running : start()
    Running --> Paused : pause()
    Running --> Stopped : stop()
    Paused --> Running : resume()
    Paused --> Stopped : stop()
    Stopped --> Idle : reset()
    Running --> Error : exception
    Error --> Idle : recover()

    state Running {
        [*] --> Processing
        Processing --> Validating
        Validating --> Processing
    }`,

                entityRelationship: `erDiagram
    CUSTOMER ||--o{ ORDER : "places"
    ORDER ||--|{ LINE-ITEM : "contains"
    CUSTOMER }|..|{ DELIVERY-ADDRESS : "uses"
    PRODUCT ||--o{ LINE-ITEM : "ordered in"
    ORDER }|--|| PAYMENT : "paid with"
    CUSTOMER }|--o{ PAYMENT : "makes"

    CUSTOMER {
        int customer_id PK
        string first_name
        string last_name
        string email
        string phone
    }

    ORDER {
        int order_id PK
        int customer_id FK
        date order_date
        decimal total_amount
        string status
    }

    PRODUCT {
        int product_id PK
        string name
        decimal price
        string category
        int stock_quantity
    }`
            };

            const code = examples[type];
            if (code) {
                document.getElementById('code').value = code;
                renderDiagram();
                closeDropdowns();
                showSuccess(`${type.charAt(0).toUpperCase() + type.slice(1)} example loaded! üìö`);
            }
        }

        // ===== EXPORT & SHARING =====

        /**
         * Get a clean SVG copy without zoom/pan transforms for export with comprehensive validation
         * This ensures exports are always at the original scale regardless of preview zoom
         */
            function getCleanSVGForExport() {
                const originalSvg = document.querySelector('#mermaidContainer svg');
                if (!originalSvg) {
                    console.error('No SVG found in mermaid container');
                    return null;
                }

                console.log('Creating clean SVG for export...');

                // Clone the SVG to avoid modifying the original
                const cleanSvg = originalSvg.cloneNode(true);

                // Remove any CSS transforms that were applied for zoom/pan
                cleanSvg.style.transform = '';
                cleanSvg.style.transformOrigin = '';
                cleanSvg.style.scale = '';

                // Ensure the clean SVG has proper attributes
                if (!cleanSvg.getAttribute('xmlns')) {
                    cleanSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                }
                if (!cleanSvg.getAttribute('xmlns:xlink')) {
                    cleanSvg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
                }

                // Preserve original viewBox if it exists
                const originalViewBox = originalSvg.getAttribute('viewBox');
                if (originalViewBox) {
                    cleanSvg.setAttribute('viewBox', originalViewBox);
                }

                // Ensure proper SVG dimensions are preserved
                const originalWidth = originalSvg.getAttribute('width');
                const originalHeight = originalSvg.getAttribute('height');
                if (originalWidth) cleanSvg.setAttribute('width', originalWidth);
                if (originalHeight) cleanSvg.setAttribute('height', originalHeight);

                // Embed comprehensive styles for text rendering consistency
                embedTextRenderingStyles(cleanSvg);

                // Validate that the clean SVG has content
                const hasContent = cleanSvg.children.length > 0 || cleanSvg.textContent.trim().length > 0;
                if (!hasContent) {
                    console.warn('Clean SVG appears to have no content');
                }

                console.log('Clean SVG created successfully with', cleanSvg.children.length, 'child elements');
                return cleanSvg;
            }

                                                /**
                                                 * Embed comprehensive text rendering styles into SVG for export consistency
                                                 * This ensures exported images match the preview text rendering exactly
                                                 */
                                                function embedTextRenderingStyles(svg) {
                                                    console.log('Embedding text rendering styles for export...');

                                                    // Get current style settings from the UI or defaults
                                                    const fontSize = document.getElementById('fontSize')?.value || '14';
                                                    const fontFamily = 'Segoe UI, Tahoma, Geneva, Verdana, sans-serif';

                                                    // Create comprehensive style element for text rendering
                                                    const styleElement = document.createElementNS('http://www.w3.org/2000/svg', 'style');
                                                    styleElement.setAttribute('type', 'text/css');

                                                    // Comprehensive CSS for text rendering consistency
                                                    const textRenderingCSS = `
                /* High-quality text rendering */
                * {
                    text-rendering: geometricPrecision;
                    shape-rendering: geometricPrecision;
                    image-rendering: optimizeQuality;
                }

                /* Comprehensive font styling for all text elements */
                text, tspan, textPath {
                    font-family: ${fontFamily} !important;
                    font-size: ${fontSize}px !important;
                    font-weight: normal !important;
                    font-style: normal !important;
                    text-anchor: inherit !important;
                    dominant-baseline: inherit !important;
                }

                /* Font styling for HTML elements inside foreignObject (Mermaid's modern approach) */
                foreignObject div, foreignObject span, foreignObject p {
                    font-family: ${fontFamily} !important;
                    font-size: ${fontSize}px !important;
                    font-weight: normal !important;
                    font-style: normal !important;
                    line-height: 1.2 !important;
                    text-align: center !important;
                    box-sizing: border-box !important;
                    margin: 0 !important;
                    padding: 0 !important;
                }

                /* Specific Mermaid text element classes */
                .nodeLabel, .edgeLabel, .cluster-label, .titleText,
                .actor-label, .messageText, .loopText, .noteText,
                .labelText, .classTitle, .classText, .stateText,
                .er-entityNameText, .er-attributeText {
                    font-family: ${fontFamily} !important;
                    font-size: ${fontSize}px !important;
                }

                /* Ensure consistent text positioning */
                text[text-anchor="start"] { text-anchor: start !important; }
                text[text-anchor="middle"] { text-anchor: middle !important; }
                text[text-anchor="end"] { text-anchor: end !important; }

                /* Preserve text baseline alignment */
                text[dominant-baseline="auto"] { dominant-baseline: auto !important; }
                text[dominant-baseline="middle"] { dominant-baseline: middle !important; }
                text[dominant-baseline="central"] { dominant-baseline: central !important; }
                text[dominant-baseline="hanging"] { dominant-baseline: hanging !important; }
            `;

                                                    styleElement.textContent = textRenderingCSS;

                                                    // Insert style element at the beginning of SVG
                                                    if (svg.firstChild) {
                                                        svg.insertBefore(styleElement, svg.firstChild);
                                                    } else {
                                                        svg.appendChild(styleElement);
                                                    }

                                                    // Apply inline styles to all text elements for maximum compatibility
                                                    applyInlineTextStyles(svg, fontSize, fontFamily);

                                                    console.log('Text rendering styles embedded successfully');
                                                }

                                                /**
                                                 * Apply inline styles to all text elements for maximum export compatibility
                                                 * This ensures text styling is preserved even when CSS is not fully supported
                                                 *
                                                 * IMPORTANT: This function handles both traditional SVG text elements and modern
                                                 * HTML-in-SVG text (via foreignObject). This fixes text misplacement issues
                                                 * that occurred when only SVG text elements were being styled during export.
                                                 */
                                                function applyInlineTextStyles(svg, fontSize, fontFamily) {
                                                    console.log('Applying inline text styles for export consistency...');

                                                    // Find all text elements in the SVG (both traditional SVG text and HTML-in-SVG)
                                                    const svgTextElements = svg.querySelectorAll('text, tspan, textPath');
                                                    const htmlTextElements = svg.querySelectorAll('foreignObject div, foreignObject span, foreignObject p');

                                                    console.log('Found SVG text elements:', svgTextElements.length);
                                                    console.log('Found HTML text elements in foreignObject:', htmlTextElements.length);

                                                    const allTextElements = [...svgTextElements, ...htmlTextElements];
                                                    console.log('Total text elements to process:', allTextElements.length);

                                                    allTextElements.forEach(textElement => {
                                                        const isSVGElement = ['text', 'tspan', 'textPath'].includes(textElement.tagName.toLowerCase());
                                                        const isHTMLElement = ['DIV', 'SPAN', 'P'].includes(textElement.tagName.toUpperCase());

                                                        if (isSVGElement) {
                                                            // Handle traditional SVG text elements
                                                            const existingX = textElement.getAttribute('x');
                                                            const existingY = textElement.getAttribute('y');
                                                            const existingDx = textElement.getAttribute('dx');
                                                            const existingDy = textElement.getAttribute('dy');
                                                            const existingTextAnchor = textElement.getAttribute('text-anchor');
                                                            const existingDominantBaseline = textElement.getAttribute('dominant-baseline');

                                                            // Apply font styling as attributes (more reliable for export)
                                                            textElement.setAttribute('font-family', fontFamily);
                                                            textElement.setAttribute('font-size', fontSize);
                                                            textElement.setAttribute('font-weight', 'normal');
                                                            textElement.setAttribute('font-style', 'normal');

                                                            // Preserve text positioning attributes
                                                            if (existingTextAnchor) {
                                                                textElement.setAttribute('text-anchor', existingTextAnchor);
                                                            }
                                                            if (existingDominantBaseline) {
                                                                textElement.setAttribute('dominant-baseline', existingDominantBaseline);
                                                            }

                                                            // Ensure positioning is preserved
                                                            if (existingX !== null) textElement.setAttribute('x', existingX);
                                                            if (existingY !== null) textElement.setAttribute('y', existingY);
                                                            if (existingDx !== null) textElement.setAttribute('dx', existingDx);
                                                            if (existingDy !== null) textElement.setAttribute('dy', existingDy);
                                                        }

                                                        if (isHTMLElement) {
                                                            // Handle HTML elements inside foreignObject (Mermaid's modern approach)
                                                            // Apply CSS styles for HTML text elements
                                                            textElement.style.fontFamily = fontFamily;
                                                            textElement.style.fontSize = fontSize + 'px';
                                                            textElement.style.fontWeight = 'normal';
                                                            textElement.style.fontStyle = 'normal';
                                                            textElement.style.lineHeight = '1.2';
                                                            textElement.style.textAlign = 'center';

                                                            // Ensure consistent box model for text positioning
                                                            textElement.style.boxSizing = 'border-box';
                                                            textElement.style.margin = '0';
                                                            textElement.style.padding = '0';
                                                        }

                                                        // Apply inline styles for additional compatibility (both SVG and HTML)
                                                        textElement.style.fontFamily = fontFamily;
                                                        textElement.style.fontSize = fontSize + 'px';
                                                        textElement.style.fontWeight = 'normal';
                                                        textElement.style.fontStyle = 'normal';
                                                    });

                                                    console.log(`Applied inline styles to ${allTextElements.length} text elements (${svgTextElements.length} SVG + ${htmlTextElements.length} HTML)`);
                                                }

                                                /**
                                                 * Setup high-quality canvas rendering for crisp text and graphics
                                                 * This addresses DPI scaling and text rendering quality issues
                                                 */
                                                function setupHighQualityCanvas(canvas, ctx, width, height) {
                                                    console.log('Setting up high-quality canvas rendering...');

                                                    // Get device pixel ratio for high-DPI displays
                                                    const devicePixelRatio = window.devicePixelRatio || 1;

                                                    // Set actual canvas size in memory (scaled for high-DPI)
                                                    canvas.width = width * devicePixelRatio;
                                                    canvas.height = height * devicePixelRatio;

                                                    // Scale the canvas back down using CSS
                                                    canvas.style.width = width + 'px';
                                                    canvas.style.height = height + 'px';

                                                    // Scale the drawing context so everything draws at the correct size
                                                    ctx.scale(devicePixelRatio, devicePixelRatio);

                                                    // Enable high-quality text rendering
                                                    ctx.textRenderingOptimization = 'optimizeQuality';
                                                    ctx.imageSmoothingEnabled = true;
                                                    ctx.imageSmoothingQuality = 'high';

                                                    // Set text rendering properties for crisp text
                                                    if (ctx.textRenderingOptimization) {
                                                        ctx.textRenderingOptimization = 'optimizeQuality';
                                                    }

                                                    console.log(`Canvas setup: ${width}x${height} (${canvas.width}x${canvas.height} actual, DPR: ${devicePixelRatio})`);
                                                }

                                                /**
                                                 * Get accurate text bounds for better text measurement in exports
                                                 * This provides more precise text positioning and sizing
                                                 */
                                                function getAccurateTextBounds(textElement) {
                                                    const isSVGElement = ['text', 'tspan', 'textPath'].includes(textElement.tagName.toLowerCase());
                                                    const isHTMLElement = ['DIV', 'SPAN', 'P'].includes(textElement.tagName.toUpperCase());

                                                    // For SVG text elements, try getBBox first
                                                    if (isSVGElement) {
                                                        try {
                                                            const bbox = textElement.getBBox();
                                                            if (bbox && bbox.width > 0 && bbox.height > 0) {
                                                                return bbox;
                                                            }
                                                        } catch (e) {
                                                            // getBBox failed, fall through to canvas measurement
                                                        }
                                                    }

                                                    // For HTML elements or when getBBox fails, use DOM measurement
                                                    if (isHTMLElement) {
                                                        try {
                                                            const rect = textElement.getBoundingClientRect();
                                                            if (rect.width > 0 && rect.height > 0) {
                                                                return {
                                                                    x: rect.left,
                                                                    y: rect.top,
                                                                    width: rect.width,
                                                                    height: rect.height
                                                                };
                                                            }
                                                        } catch (e) {
                                                            // getBoundingClientRect failed, fall through to canvas measurement
                                                        }
                                                    }

                                                    // Fallback: Canvas-based text measurement for both SVG and HTML elements
                                                    try {
                                                        const text = textElement.textContent || textElement.innerText || '';
                                                        if (!text.trim()) return null;

                                                        // Get font properties with better fallback handling
                                                        const computedStyle = window.getComputedStyle(textElement);
                                                        const fontSize = parseFloat(
                                                            textElement.getAttribute('font-size') ||
                                                            textElement.style.fontSize ||
                                                            computedStyle.fontSize ||
                                                            document.getElementById('fontSize')?.value ||
                                                            '14'
                                                        );
                                                        const fontFamily =
                                                            textElement.getAttribute('font-family') ||
                                                            textElement.style.fontFamily ||
                                                            computedStyle.fontFamily ||
                                                            'Segoe UI, Tahoma, Geneva, Verdana, sans-serif';

                                                        // Create temporary canvas for text measurement
                                                        const canvas = document.createElement('canvas');
                                                        const ctx = canvas.getContext('2d');
                                                        ctx.font = `${fontSize}px ${fontFamily}`;

                                                        const metrics = ctx.measureText(text);

                                                        // Get position based on element type
                                                        let x = 0, y = 0;
                                                        if (isSVGElement) {
                                                            x = parseFloat(textElement.getAttribute('x') || 0);
                                                            y = parseFloat(textElement.getAttribute('y') || 0);
                                                        } else if (isHTMLElement) {
                                                            const rect = textElement.getBoundingClientRect();
                                                            x = rect.left;
                                                            y = rect.top;
                                                        }

                                                        return {
                                                            x: x,
                                                            y: y - fontSize * 0.8,
                                                            width: metrics.width,
                                                            height: fontSize * 1.2
                                                        };
                                                    } catch (e) {
                                                        console.warn('Text measurement failed:', e);
                                                        return null;
                                                    }
                                                }

                                                /**
                                                 * Ensure fonts are loaded before rendering to canvas
                                                 * This prevents text rendering issues in exported images
                                                 */
                                                function ensureFontsLoaded() {
                                                    return new Promise((resolve, reject) => {
                                                        // Check if Font Loading API is available
                                                        if ('fonts' in document) {
                                                            // Wait for fonts to be ready
                                                            document.fonts.ready.then(() => {
                                                                console.log('Fonts loaded successfully');
                                                                resolve();
                                                            }).catch(error => {
                                                                console.warn('Font loading API failed:', error);
                                                                // Fallback to timeout
                                                                setTimeout(resolve, 100);
                                                            });
                                                        } else {
                                                            // Fallback for browsers without Font Loading API
                                                            console.log('Font Loading API not available, using timeout fallback');
                                                            setTimeout(resolve, 100);
                                                        }
                                                    });
                                                }

        /**
         * Calculate the actual content bounds of an SVG element with comprehensive element detection
         * This ensures we capture ALL visible content including text, paths, shapes, and Mermaid-specific elements
         */
        function calculateSVGContentBounds(svg) {
            try {
                console.log('Calculating SVG content bounds for export...');

                // Create a temporary SVG in the DOM to get accurate measurements
                const tempContainer = document.createElement('div');
                tempContainer.style.position = 'absolute';
                tempContainer.style.left = '-9999px';
                tempContainer.style.top = '-9999px';
                tempContainer.style.visibility = 'hidden';
                document.body.appendChild(tempContainer);

                // Clone the SVG for measurement
                const tempSvg = svg.cloneNode(true);
                tempSvg.style.transform = 'none'; // Remove any transforms
                tempSvg.style.transformOrigin = 'initial';
                tempContainer.appendChild(tempSvg);

                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                let hasValidBounds = false;

                // Get all elements that contribute to visual content
                const contentSelectors = [
                    'rect', 'circle', 'ellipse', 'line', 'polyline', 'polygon', 'path',
                    'text', 'tspan', 'textPath', 'g[class*="node"]', 'g[class*="edge"]',
                    'g[class*="label"]', 'marker', 'use', 'image', 'foreignObject'
                ];

                const allContentElements = tempSvg.querySelectorAll(contentSelectors.join(','));
                console.log(`Found ${allContentElements.length} content elements to analyze`);

                // Analyze each content element
                for (const element of allContentElements) {
                    try {
                        // Skip invisible or non-contributing elements
                        if (element.style.display === 'none' ||
                            element.style.visibility === 'hidden' ||
                            element.getAttribute('opacity') === '0') {
                            continue;
                        }

                        let bbox = null;

                        // Try getBBox first (most accurate for SVG elements)
                        if (typeof element.getBBox === 'function') {
                            try {
                                bbox = element.getBBox();
                            } catch (e) {
                                // getBBox can fail on some elements, continue to fallback
                            }
                        }

                        // Fallback for elements where getBBox fails
                        if (!bbox || bbox.width === 0 || bbox.height === 0) {
                            // Handle specific element types with improved text measurement
                            if (element.tagName === 'text' || element.tagName === 'tspan' ||
                                element.tagName === 'DIV' || element.tagName === 'SPAN' || element.tagName === 'P') {
                            // For text elements (both SVG and HTML), get accurate text metrics
                                bbox = getAccurateTextBounds(element);
                                if (!bbox) {
                                    // Fallback for SVG text elements
                                    if (element.tagName === 'text' || element.tagName === 'tspan') {
                                        const textLength = element.getComputedTextLength ? element.getComputedTextLength() : 0;
                                        if (textLength > 0) {
                                            const x = parseFloat(element.getAttribute('x') || 0);
                                            const y = parseFloat(element.getAttribute('y') || 0);
                                            const fontSize = parseFloat(element.getAttribute('font-size') ||
                                                element.style.fontSize ||
                                                document.getElementById('fontSize')?.value || 14);
                                            bbox = {
                                                x: x,
                                                y: y - fontSize * 0.8,
                                                width: textLength,
                                                height: fontSize * 1.2
                                            };
                                        }
                                    }
                                    // Fallback for HTML text elements
                                    else if (element.tagName === 'DIV' || element.tagName === 'SPAN' || element.tagName === 'P') {
                                        try {
                                            const rect = element.getBoundingClientRect();
                                            if (rect.width > 0 && rect.height > 0) {
                                                bbox = {
                                                    x: rect.left,
                                                    y: rect.top,
                                                    width: rect.width,
                                                    height: rect.height
                                                };
                                            }
                                        } catch (e) {
                                            // getBoundingClientRect failed, skip this element
                                        }
                                    }
                                }
                            } else if (element.tagName === 'g') {
                                // For groups, try to get the bounding box of children
                                try {
                                    bbox = element.getBBox();
                                } catch (e) {
                                    // If group getBBox fails, calculate from children
                                    const children = element.children;
                                    if (children.length > 0) {
                                        let gMinX = Infinity, gMinY = Infinity, gMaxX = -Infinity, gMaxY = -Infinity;
                                        for (const child of children) {
                                            try {
                                                const childBbox = child.getBBox();
                                                if (childBbox && childBbox.width > 0 && childBbox.height > 0) {
                                                    gMinX = Math.min(gMinX, childBbox.x);
                                                    gMinY = Math.min(gMinY, childBbox.y);
                                                    gMaxX = Math.max(gMaxX, childBbox.x + childBbox.width);
                                                    gMaxY = Math.max(gMaxY, childBbox.y + childBbox.height);
                                                }
                                            } catch (e) {
                                                continue;
                                            }
                                        }
                                        if (gMinX !== Infinity) {
                                            bbox = {
                                                x: gMinX,
                                                y: gMinY,
                                                width: gMaxX - gMinX,
                                                height: gMaxY - gMinY
                                            };
                                        }
                                    }
                                }
                            }
                        }

                        // Update overall bounds if we got a valid bbox
                        if (bbox && bbox.width > 0 && bbox.height > 0 &&
                            isFinite(bbox.x) && isFinite(bbox.y)) {
                            minX = Math.min(minX, bbox.x);
                            minY = Math.min(minY, bbox.y);
                            maxX = Math.max(maxX, bbox.x + bbox.width);
                            maxY = Math.max(maxY, bbox.y + bbox.height);
                            hasValidBounds = true;
                        }
                    } catch (e) {
                        console.warn('Error analyzing element:', element.tagName, e);
                        continue;
                    }
                }

                // Clean up temporary elements
                document.body.removeChild(tempContainer);

                // Return calculated bounds if valid
                if (hasValidBounds && minX !== Infinity && isFinite(minX) && isFinite(minY)) {
                    const bounds = {
                        x: minX,
                        y: minY,
                        width: maxX - minX,
                        height: maxY - minY
                    };
                    console.log('Calculated content bounds:', bounds);
                    return bounds;
                }

                // Enhanced fallback strategies
                console.log('Primary bounds calculation failed, trying fallbacks...');

                // Fallback 1: Try root SVG getBBox
                try {
                    const rootBbox = svg.getBBox();
                    if (rootBbox && rootBbox.width > 0 && rootBbox.height > 0) {
                        console.log('Using root SVG getBBox:', rootBbox);
                        return rootBbox;
                    }
                } catch (e) {
                    console.warn('Root SVG getBBox failed:', e);
                }

                // Fallback 2: Use viewBox if available
                if (svg.viewBox && svg.viewBox.baseVal) {
                    const vb = svg.viewBox.baseVal;
                    if (vb.width > 0 && vb.height > 0) {
                        const viewBoxBounds = {
                            x: vb.x,
                            y: vb.y,
                            width: vb.width,
                            height: vb.height
                        };
                        console.log('Using viewBox bounds:', viewBoxBounds);
                        return viewBoxBounds;
                    }
                }

                // Fallback 3: Use SVG width/height attributes
                const width = svg.getAttribute('width');
                const height = svg.getAttribute('height');
                if (width && height) {
                    const attrBounds = {
                        x: 0,
                        y: 0,
                        width: parseFloat(width),
                        height: parseFloat(height)
                    };
                    console.log('Using SVG attribute bounds:', attrBounds);
                    return attrBounds;
                }

                console.warn('All bounds calculation methods failed');
                return null;
            } catch (error) {
                console.error('Critical error in calculateSVGContentBounds:', error);
                return null;
            }
        }

        function exportDiagram(format) {
            exportMermaidDiagram(format);
        }

        function quickExport() {
            const format = document.getElementById('exportFormat')?.value || 'png';
            exportMermaidDiagram(format);
        }

                    /**
                     * Validate text positioning consistency between display and export
                     * This function helps verify that the text positioning fixes are working correctly
                     */
                    function validateTextPositioning() {
                        console.log('üîç Validating text positioning consistency...');

                        const originalSvg = document.querySelector('#mermaidContainer svg');
                        if (!originalSvg) {
                            console.error('‚ùå No diagram found. Please render a diagram first.');
                            return false;
                        }

                        // Get clean SVG for export
                        const cleanSvg = getCleanSVGForExport();
                        if (!cleanSvg) {
                            console.error('‚ùå Failed to create clean SVG for validation.');
                            return false;
                        }

                        // Count text elements in both versions
                        const originalSvgTextElements = originalSvg.querySelectorAll('text, tspan, textPath');
                        const originalHtmlTextElements = originalSvg.querySelectorAll('foreignObject div, foreignObject span, foreignObject p');
                        const originalTotal = originalSvgTextElements.length + originalHtmlTextElements.length;

                        const cleanSvgTextElements = cleanSvg.querySelectorAll('text, tspan, textPath');
                        const cleanHtmlTextElements = cleanSvg.querySelectorAll('foreignObject div, foreignObject span, foreignObject p');
                        const cleanTotal = cleanSvgTextElements.length + cleanHtmlTextElements.length;

                        console.log(`üìä Original diagram: ${originalTotal} text elements (${originalSvgTextElements.length} SVG + ${originalHtmlTextElements.length} HTML)`);
                        console.log(`üìä Export version: ${cleanTotal} text elements (${cleanSvgTextElements.length} SVG + ${cleanHtmlTextElements.length} HTML)`);

                        // Validate text element count consistency
                        if (originalTotal !== cleanTotal) {
                            console.warn(`‚ö†Ô∏è Text element count mismatch: ${originalTotal} vs ${cleanTotal}`);
                        } else {
                            console.log('‚úÖ Text element count is consistent');
                        }

                        // Validate font styling application
                        let styledElements = 0;
                        [...cleanSvgTextElements, ...cleanHtmlTextElements].forEach(element => {
                            const hasFont = element.style.fontFamily || element.getAttribute('font-family');
                            const hasFontSize = element.style.fontSize || element.getAttribute('font-size');
                            if (hasFont && hasFontSize) {
                                styledElements++;
                            }
                        });

                        console.log(`üé® Styled text elements: ${styledElements}/${cleanTotal}`);

                        if (styledElements === cleanTotal) {
                            console.log('‚úÖ All text elements have consistent font styling');
                            return true;
                        } else {
                            console.warn(`‚ö†Ô∏è ${cleanTotal - styledElements} text elements missing font styling`);
                            return false;
                        }
                    }

                                                    /**
                                                     * Auto-fix export content to ensure exports always succeed
                                                     * Instead of blocking exports, automatically correct any issues
                                                     */
                                                    function autoFixExportContent(svg) {
                                                        const fixes = {
                                                            applied: [],
                                                            warnings: [],
                                                            elementCounts: {}
                                                        };

                                                        try {
                                                            // Count different types of elements for informational purposes
                                                            const elementTypes = ['rect', 'circle', 'ellipse', 'line', 'polyline', 'polygon', 'path', 'text', 'g'];
                                                            elementTypes.forEach(type => {
                                                                const elements = svg.querySelectorAll(type);
                                                                fixes.elementCounts[type] = elements.length;
                                                            });

                                                            // Auto-fix SVG dimensions if invalid
                                                            let width = svg.getAttribute('width');
                                                            let height = svg.getAttribute('height');

                                                            if (!width || !height || width === '0' || height === '0' || width === 'undefined' || height === 'undefined') {
                                                                // Calculate dimensions from viewBox or bounding box
                                                                const viewBox = svg.getAttribute('viewBox');
                                                                if (viewBox) {
                                                                    const [x, y, w, h] = viewBox.split(' ').map(Number);
                                                                    width = w || 800;
                                                                    height = h || 600;
                                                                } else {
                                                                    // Try to get bounding box
                                                                    try {
                                                                        const bbox = svg.getBBox();
                                                                        width = bbox.width || 800;
                                                                        height = bbox.height || 600;
                                                                    } catch (e) {
                                                                        // Fallback to default dimensions
                                                                        width = 800;
                                                                        height = 600;
                                                                    }
                                                                }

                                                                // Apply the corrected dimensions
                                                                svg.setAttribute('width', width);
                                                                svg.setAttribute('height', height);
                                                                fixes.applied.push(`Auto-corrected dimensions to ${width}x${height}`);
                                                            }

                                                            // Ensure viewBox exists
                                                            if (!svg.getAttribute('viewBox')) {
                                                                svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
                                                                fixes.applied.push('Added missing viewBox');
                                                            }

                                                            // Add informational warnings (non-blocking)
                                                            if (fixes.elementCounts.text === 0 && fixes.elementCounts.g === 0) {
                                                                fixes.warnings.push('Diagram appears to be empty - this is still exportable');
                                                            }

                                                            if (fixes.elementCounts.path === 0 && fixes.elementCounts.line === 0) {
                                                                fixes.warnings.push('No connections found - diagram may only contain nodes');
                                                            }

                                                            console.log('Export auto-fixes applied:', fixes);
                                                            return fixes;
                                                        } catch (error) {
                                                            console.error('Export auto-fix failed:', error);
                                                            fixes.warnings.push('Auto-fix failed: ' + error.message);
                                                            return fixes;
                                                        }
                                                    }

        function exportMermaidDiagram(format) {
            // Get a clean SVG without zoom/pan transforms for export
            const cleanSvg = getCleanSVGForExport();
            if (!cleanSvg) {
                showError('No diagram to export. Please render a diagram first.');
                return;
            }

            // Auto-fix any export issues instead of blocking
            const fixes = autoFixExportContent(cleanSvg);

            // Show informational messages about fixes applied
            if (fixes.applied.length > 0) {
                console.log('Export fixes applied:', fixes.applied);
                showSuccess(`Export ready! Applied ${fixes.applied.length} auto-fix(es) ‚ú®`);
            }

            if (fixes.warnings.length > 0) {
                console.warn('Export warnings (non-blocking):', fixes.warnings);
            }

            closeDropdowns();

            try {
                if (format === 'svg') {
                    exportMermaidSVG(cleanSvg);
                } else if (format === 'png') {
                    exportMermaidPNG(cleanSvg);
                } else {
                    showError('Unsupported export format: ' + format);
                }
            } catch (error) {
                showError('Export failed: ' + error.message);
                console.error('Export error:', error);
            }
        }

        function exportMermaidSVG(svg) {
            try {
                // Get export settings
                const padding = parseInt(document.getElementById('exportPadding')?.value) || 20;
                const autoFit = document.getElementById('autoFitContent')?.value === 'true';

                // The SVG is already clean (no transforms), so we can work with it directly
                // Clone it once more to avoid any potential modifications
                const svgClone = svg.cloneNode(true);

                if (autoFit) {
                    // Calculate the actual content bounds
                    const contentBounds = calculateSVGContentBounds(svg);

                    if (contentBounds) {
                        // Add padding to the bounds
                        const paddedBounds = {
                            x: contentBounds.x - padding,
                            y: contentBounds.y - padding,
                            width: contentBounds.width + (padding * 2),
                            height: contentBounds.height + (padding * 2)
                        };

                        // Update the SVG clone with the new viewBox and dimensions
                        svgClone.setAttribute('viewBox', `${paddedBounds.x} ${paddedBounds.y} ${paddedBounds.width} ${paddedBounds.height}`);
                        svgClone.setAttribute('width', paddedBounds.width);
                        svgClone.setAttribute('height', paddedBounds.height);
                    }
                }

                // XML namespaces are already set by getCleanSVGForExport()

                // Get the SVG content
                const svgData = new XMLSerializer().serializeToString(svgClone);
                const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });

                // Create download link
                const link = document.createElement('a');
                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                link.download = `mermaid-diagram-${timestamp}.svg`;
                link.href = URL.createObjectURL(blob);
                link.click();

                // Clean up
                URL.revokeObjectURL(link.href);
                showSuccess('Complete diagram exported as SVG! üìÑ');
            } catch (error) {
                showError('Failed to export SVG: ' + error.message);
                console.error('SVG export error:', error);
            }
        }

        function exportMermaidPNG(svg) {
            try {
                showLoading(true);

                // Get export settings
                const scaleFactor = parseInt(document.getElementById('pngQuality')?.value) || 2;
                const background = document.getElementById('exportBackground')?.value || 'white';
                const padding = parseInt(document.getElementById('exportPadding')?.value) || 20;
                const autoFit = document.getElementById('autoFitContent')?.value === 'true';

                let baseWidth, baseHeight, viewBoxX = 0, viewBoxY = 0;

                if (autoFit) {
                    // Calculate the actual content bounds for accurate sizing
                    const contentBounds = calculateSVGContentBounds(svg);

                    if (contentBounds) {
                        // Use content bounds with padding
                        baseWidth = contentBounds.width + (padding * 2);
                        baseHeight = contentBounds.height + (padding * 2);
                        viewBoxX = contentBounds.x - padding;
                        viewBoxY = contentBounds.y - padding;
                    } else {
                        // Fallback to original method
                        baseWidth = svg.viewBox?.baseVal?.width || svg.width?.baseVal?.value || svg.getBoundingClientRect().width;
                        baseHeight = svg.viewBox?.baseVal?.height || svg.height?.baseVal?.value || svg.getBoundingClientRect().height;
                    }
                } else {
                    // Use original SVG dimensions
                    baseWidth = svg.viewBox?.baseVal?.width || svg.width?.baseVal?.value || svg.getBoundingClientRect().width;
                    baseHeight = svg.viewBox?.baseVal?.height || svg.height?.baseVal?.value || svg.getBoundingClientRect().height;
                }

                // Ensure minimum dimensions for quality
                baseWidth = Math.max(baseWidth, 400);
                baseHeight = Math.max(baseHeight, 300);

                // Calculate high-resolution dimensions
                const finalWidth = baseWidth * scaleFactor;
                const finalHeight = baseHeight * scaleFactor;

                // Create high-DPI canvas
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                // Set actual canvas size to high resolution
                canvas.width = finalWidth;
                canvas.height = finalHeight;

                // Set CSS size to maintain aspect ratio
                canvas.style.width = baseWidth + 'px';
                canvas.style.height = baseHeight + 'px';

                // Enable high-quality rendering
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                ctx.textRenderingOptimization = 'optimizeQuality';

                // Set background if specified
                if (background === 'white') {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, finalWidth, finalHeight);
                }

                // The SVG is already clean (no transforms), prepare it for high-resolution export
                const svgClone = svg.cloneNode(true);

                // Set explicit dimensions for crisp rendering
                svgClone.setAttribute('width', finalWidth);
                svgClone.setAttribute('height', finalHeight);

                // Set viewBox to capture the correct content area
                if (autoFit && viewBoxX !== undefined && viewBoxY !== undefined) {
                    svgClone.setAttribute('viewBox', `${viewBoxX} ${viewBoxY} ${baseWidth} ${baseHeight}`);
                } else {
                    svgClone.setAttribute('viewBox', `0 0 ${baseWidth} ${baseHeight}`);
                }

                // XML namespaces are already set by getCleanSVGForExport()

                // Enhanced canvas rendering setup for high-quality text
                setupHighQualityCanvas(canvas, ctx, finalWidth, finalHeight);

                // The SVG already has comprehensive text rendering styles embedded
                // from the getCleanSVGForExport() function, so no additional styling needed here

                // Serialize SVG with proper encoding
                const svgString = new XMLSerializer().serializeToString(svgClone);
                const encodedSvg = encodeURIComponent(svgString);
                const svgDataUrl = `data:image/svg+xml;charset=utf-8,${encodedSvg}`;

                const img = new Image();
                img.onload = function () {
                    try {
                        // Ensure fonts are loaded before drawing
                        ensureFontsLoaded().then(() => {
                            // Draw at full resolution for maximum quality
                            ctx.drawImage(img, 0, 0, finalWidth, finalHeight);

                            // Convert to PNG with maximum quality
                            canvas.toBlob(function (blob) {
                            showLoading(false);

                            if (blob) {
                                // Create download link
                                const link = document.createElement('a');
                                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                                const fileSize = (blob.size / (1024 * 1024)).toFixed(2);
                                link.download = `mermaid-diagram-${finalWidth}x${finalHeight}-${timestamp}.png`;
                                link.href = URL.createObjectURL(blob);

                                // Trigger download
                                document.body.appendChild(link);
                                link.click();
                                document.body.removeChild(link);

                                // Clean up
                                URL.revokeObjectURL(link.href);
                                showSuccess(`Complete diagram exported as PNG! (${finalWidth}√ó${finalHeight}, ${fileSize}MB) üñºÔ∏è`);
                            } else {
                                showError('Failed to create PNG file');
                            }
                        }, 'image/png', 1.0); // Maximum quality

                        }).catch(fontError => {
                            showLoading(false);
                            console.warn('Font loading failed, proceeding anyway:', fontError);
                            // Fallback: draw without waiting for fonts
                            ctx.drawImage(img, 0, 0, finalWidth, finalHeight);
                            canvas.toBlob(function (blob) {
                                showLoading(false);
                                if (blob) {
                                    const link = document.createElement('a');
                                    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                                    const fileSize = (blob.size / (1024 * 1024)).toFixed(2);
                                    link.download = `mermaid-diagram-${finalWidth}x${finalHeight}-${timestamp}.png`;
                                    link.href = URL.createObjectURL(blob);
                                    document.body.appendChild(link);
                                    link.click();
                                    document.body.removeChild(link);
                                    URL.revokeObjectURL(link.href);
                                    showSuccess(`Complete diagram exported as PNG! (${finalWidth}√ó${finalHeight}, ${fileSize}MB) üñºÔ∏è`);
                                } else {
                                    showError('Failed to create PNG file');
                                }
                            }, 'image/png', 1.0);
                        });

                    } catch (drawError) {
                        showLoading(false);
                        console.error('Canvas draw error:', drawError);
                        showError('Failed to draw diagram on canvas');
                    }
                };

                img.onerror = function (error) {
                    showLoading(false);
                    console.error('Image load error:', error);
                    showError('Failed to load SVG for PNG conversion. Try a simpler diagram or different export format.');
                };

                // Set image source to trigger loading
                img.src = svgDataUrl;

            } catch (error) {
                showLoading(false);
                showError('PNG export failed: ' + error.message);
                console.error('PNG export error:', error);
            }
        }

        function copyToClipboard(type) {
            closeDropdowns();

            if (type === 'code') {
                const code = document.getElementById('code').value;
                navigator.clipboard.writeText(code).then(() => {
                    showSuccess('Code copied to clipboard! üìù');
                }).catch(() => {
                    showError('Failed to copy to clipboard.');
                });
            } else if (type === 'svg') {
                // Get clean SVG without zoom/pan transforms
                const cleanSvg = getCleanSVGForExport();
                if (!cleanSvg) {
                    showError('No diagram to copy. Please render a diagram first.');
                    return;
                }

                const svgData = new XMLSerializer().serializeToString(cleanSvg);
                navigator.clipboard.writeText(svgData).then(() => {
                    showSuccess('SVG copied to clipboard! üìã');
                }).catch(() => {
                    showError('Failed to copy SVG to clipboard.');
                });
            }
        }

        function shareURL() {
            const code = document.getElementById('code').value;
            if (!code.trim()) {
                showError('No diagram to share.');
                return;
            }

            const encodedCode = btoa(unescape(encodeURIComponent(code)));
            const url = window.location.origin + window.location.pathname + '?code=' + encodedCode;

            navigator.clipboard.writeText(url).then(() => {
                showSuccess('Shareable URL copied to clipboard! üîó');
            }).catch(() => {
                showError('Failed to copy URL to clipboard.');
            });

            closeDropdowns();
        }

        // ===== FILE OPERATIONS =====
        function importFile() {
            document.getElementById('fileInput').click();
        }

        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                document.getElementById('code').value = e.target.result;
                renderDiagram();
                showSuccess(`File "${file.name}" imported successfully! üìÅ`);
            };
            reader.readAsText(file);
        }

        function clearDiagram() {
            if (confirm('Are you sure you want to clear the diagram?')) {
                document.getElementById('code').value = '';
                const mermaidContainer = document.getElementById('mermaidDiagram');
                mermaidContainer.innerHTML = '';
                saveToStorage();
                showSuccess('Diagram cleared! üóëÔ∏è');
            }
        }

        // ===== UTILITY FUNCTIONS =====
        function showLoading(show) {
            const overlay = document.getElementById('loadingOverlay');
            if (show) {
                overlay.classList.add('active');
            } else {
                overlay.classList.remove('active');
            }
        }

        function showError(message) {
            const errorEl = document.getElementById('errorMessage');
            errorEl.textContent = message;
            errorEl.classList.add('active');

            setTimeout(() => {
                errorEl.classList.remove('active');
            }, 5000);
        }

        function clearError() {
            document.getElementById('errorMessage').classList.remove('active');
        }

        function showSuccess(message) {
            const successEl = document.getElementById('successMessage');
            successEl.textContent = message;
            successEl.classList.add('show');

            setTimeout(() => {
                successEl.classList.remove('show');
            }, 3000);
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function generateHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return hash.toString();
        }

        // ===== SETTINGS FUNCTIONS =====
        function changeTheme(theme) {
            // Remove active class from all theme buttons
            document.querySelectorAll('.theme-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.style.border = '2px solid transparent';
            });

            // Add active class to selected theme button
            const selectedBtn = document.querySelector(`[data-theme="${theme}"]`);
            if (selectedBtn) {
                selectedBtn.classList.add('active');
                selectedBtn.style.border = '2px solid #3498db';
            }

            // Apply theme to Mermaid
            let mermaidTheme = 'default';
            switch (theme) {
                case 'blue':
                    mermaidTheme = 'base';
                    break;
                case 'red':
                    mermaidTheme = 'dark';
                    break;
                case 'green':
                    mermaidTheme = 'forest';
                    break;
                default:
                    mermaidTheme = 'default';
            }

            // Reinitialize Mermaid with new theme
            mermaid.initialize({
                startOnLoad: false,
                theme: mermaidTheme,
                securityLevel: 'loose',
                fontFamily: 'Segoe UI, Tahoma, Geneva, Verdana, sans-serif',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true,
                    curve: 'basis'
                }
            });

            // Re-render diagram with new theme
            renderDiagram();
            showSuccess(`Theme changed to ${theme}! üé®`);
        }

                                                            /**
                                                             * Update range input display values in real-time
                                                             */
                                                            function updateRangeDisplay(inputId, unit) {
                                                                const input = document.getElementById(inputId);
                                                                const display = document.getElementById(inputId + 'Value');
                                                                if (input && display) {
                                                                    display.textContent = input.value + unit;
                                                                }
                                                            }

                                                            /**
                                                             * Update layout and structure settings
                                                             */
                                                            function updateLayoutSettings() {
            const nodeSpacing = document.getElementById('nodeSpacing').value;
            const rankSpacing = document.getElementById('rankSpacing').value;
            const curveStyle = document.getElementById('curveStyle').value;
                                                            const direction = document.getElementById('diagramDirection').value;

                                                            // Update range displays
                                                            updateRangeDisplay('nodeSpacing', 'px');
                                                            updateRangeDisplay('rankSpacing', 'px');

                                                            // Update diagram direction by modifying the code
                                                            const codeEditor = document.getElementById('code');
                                                            let code = codeEditor.value;

                                                            // Update direction in flowchart/graph diagrams
                                                            if (code.includes('graph ') || code.includes('flowchart ')) {
                                                                // Replace existing direction or add it
                                                                code = code.replace(/^(graph|flowchart)\s+(TD|LR|BT|RL|TB)/gm, `$1 ${direction}`);

                                                                // If no direction was found, add it to the first graph/flowchart line
                                                                if (!code.match(/^(graph|flowchart)\s+(TD|LR|BT|RL|TB)/m)) {
                                                                    code = code.replace(/^(graph|flowchart)(\s|$)/gm, `$1 ${direction}$2`);
                                                                }

                                                                codeEditor.value = code;
                                                            }

                                                            // Update Mermaid configuration for layout
            mermaid.initialize({
                startOnLoad: false,
                theme: 'default',
                securityLevel: 'loose',
                fontFamily: 'Segoe UI, Tahoma, Geneva, Verdana, sans-serif',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true,
                    curve: curveStyle,
                    nodeSpacing: parseInt(nodeSpacing),
                    rankSpacing: parseInt(rankSpacing)
                }
            });

                                                            // Re-render diagram with new layout settings
                                                            renderDiagram();
                                                                    showSuccess('Layout settings updated! üìê');
                                                                }

                                                                /**
                                                                 * Update appearance and visual settings
                                                                 */
                                                                function updateAppearanceSettings() {
                                                                    const fontSize = document.getElementById('fontSize').value;
                                                                    const lineWidth = document.getElementById('lineWidth').value;
                                                                    const nodeBorder = document.getElementById('nodeBorder').value;
                                                                    const cornerRadius = document.getElementById('cornerRadius').value;

                                                                    // Update range displays
                                                                    updateRangeDisplay('lineWidth', 'px');
                                                                    updateRangeDisplay('cornerRadius', 'px');

                                                                    // Apply visual settings via CSS custom properties
                                                                    const root = document.documentElement;
                                                                    root.style.setProperty('--mermaid-font-size', fontSize + 'px');
                                                                    root.style.setProperty('--mermaid-line-width', lineWidth + 'px');
                                                                    root.style.setProperty('--mermaid-border-width', nodeBorder + 'px');
                                                                    root.style.setProperty('--mermaid-corner-radius', cornerRadius + 'px');

                                                                    // Apply styles directly to the Mermaid container
                                                                    applyAppearanceStyles(fontSize, lineWidth, nodeBorder, cornerRadius);

                                                                    // Apply styles immediately to existing diagram without re-render
                                                                    applyStylesToExistingDiagram(fontSize, lineWidth, nodeBorder, cornerRadius);

                                                                    // Re-render diagram with new appearance settings for full effect
                                                                    renderDiagram();
                                                                    showSuccess('Appearance settings updated! üé®');
                                                                }

                                                                /**
                                                                 * Apply appearance styles directly to Mermaid SVG elements
                                                                 */
                                                                function applyAppearanceStyles(fontSize, lineWidth, nodeBorder, cornerRadius) {
                                                                    // Create or update the style element for Mermaid customization
                                                                    let styleElement = document.getElementById('mermaid-custom-styles');
                                                                    if (!styleElement) {
                                                                        styleElement = document.createElement('style');
                                                                        styleElement.id = 'mermaid-custom-styles';
                                                                        document.head.appendChild(styleElement);
                                                                    }

                                                                    // Define CSS rules that will apply to Mermaid SVG elements
                                                                    const customCSS = `
                /* Mermaid appearance customization - Font Size for ALL text elements with maximum specificity */
                #mermaidContainer svg text,
                #mermaidContainer text,
                .mermaid svg text,
                .mermaid text,
                #mermaidDiagram svg text,
                #mermaidDiagram text,
                svg text,
                div#mermaidContainer svg text,
                div.mermaid svg text,
                div#mermaidDiagram svg text,
                #mermaidContainer svg g text,
                .mermaid svg g text,
                #mermaidDiagram svg g text,
                svg g text,
                text {
                    font-size: ${fontSize}px !important;
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif !important;
                }

                /* Target specific Mermaid text classes */
                .nodeLabel,
                .edgeLabel,
                .cluster-label,
                .titleText,
                .actor-label,
                .messageText,
                .loopText,
                .noteText,
                .labelText,
                .classTitle,
                .classText,
                .stateText,
                .er-entityNameText,
                .er-attributeText {
                    font-size: ${fontSize}px !important;
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif !important;
                }

                /* Ultra-specific override for all text in Mermaid containers */
                #mermaidContainer * text,
                .mermaid * text,
                #mermaidDiagram * text,
                div[id*="mermaid"] text,
                svg[id*="mermaid"] text {
                    font-size: ${fontSize}px !important;
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif !important;
                }

                /* Force override any inline styles */
                #mermaidContainer [style*="font-size"],
                .mermaid [style*="font-size"],
                #mermaidDiagram [style*="font-size"] {
                    font-size: ${fontSize}px !important;
                }

                /* Node borders for flowcharts and general diagrams */
                #mermaidContainer svg rect,
                #mermaidContainer svg circle,
                #mermaidContainer svg ellipse,
                #mermaidContainer svg polygon,
                #mermaidContainer svg path.node,
                .mermaid svg rect,
                .mermaid svg circle,
                .mermaid svg ellipse,
                .mermaid svg polygon,
                .mermaid svg .node rect,
                .mermaid svg .node circle,
                .mermaid svg .node ellipse,
                .mermaid svg .node polygon,
                .mermaid svg .node path,
                #mermaidDiagram svg rect,
                #mermaidDiagram svg circle,
                #mermaidDiagram svg ellipse,
                #mermaidDiagram svg polygon,
                svg rect,
                svg circle,
                svg ellipse,
                svg polygon {
                    stroke-width: ${nodeBorder}px !important;
                    rx: ${cornerRadius}px !important;
                    ry: ${cornerRadius}px !important;
                }

                /* Edge/line styling */
                #mermaidContainer svg .edgePath path,
                #mermaidContainer svg .flowchart-link,
                .mermaid svg .edgePath path,
                .mermaid svg .flowchart-link {
                    stroke-width: ${lineWidth}px !important;
                }

                /* Edge labels */
                #mermaidContainer svg .edgeLabel rect,
                .mermaid svg .edgeLabel rect {
                    rx: ${Math.max(cornerRadius - 2, 0)}px !important;
                    ry: ${Math.max(cornerRadius - 2, 0)}px !important;
                }

                /* Sequence diagram elements */
                #mermaidContainer svg .actor,
                #mermaidContainer svg .boundary,
                #mermaidContainer svg .control,
                #mermaidContainer svg .entity,
                #mermaidContainer svg .database,
                .mermaid svg .actor,
                .mermaid svg .boundary,
                .mermaid svg .control,
                .mermaid svg .entity,
                .mermaid svg .database {
                    stroke-width: ${nodeBorder}px !important;
                }

                /* Sequence diagram message lines */
                #mermaidContainer svg .messageLine0,
                #mermaidContainer svg .messageLine1,
                .mermaid svg .messageLine0,
                .mermaid svg .messageLine1 {
                    stroke-width: ${lineWidth}px !important;
                }

                /* Class diagram elements */
                #mermaidContainer svg .classBox,
                .mermaid svg .classBox {
                    stroke-width: ${nodeBorder}px !important;
                    rx: ${cornerRadius}px !important;
                    ry: ${cornerRadius}px !important;
                }

                /* State diagram elements */
                #mermaidContainer svg .state-start,
                #mermaidContainer svg .state-end,
                #mermaidContainer svg .stateBox,
                .mermaid svg .state-start,
                .mermaid svg .state-end,
                .mermaid svg .stateBox {
                    stroke-width: ${nodeBorder}px !important;
                    rx: ${cornerRadius}px !important;
                    ry: ${cornerRadius}px !important;
                }

                /* ER diagram elements */
                #mermaidContainer svg .er,
                #mermaidContainer svg .entityBox,
                .mermaid svg .er,
                .mermaid svg .entityBox {
                    stroke-width: ${nodeBorder}px !important;
                    rx: ${cornerRadius}px !important;
                    ry: ${cornerRadius}px !important;
                }
            `;

                                                                    styleElement.textContent = customCSS;

        // Set up MutationObserver to catch dynamically added text elements
        setupFontSizeObserver(fontSize);
    }

    /**
     * Set up MutationObserver to apply font size to dynamically added text elements
     */
    function setupFontSizeObserver(fontSize) {
        const mermaidContainer = document.getElementById('mermaidContainer');
        if (!mermaidContainer) return;

        // Disconnect any existing observer
        if (window.fontSizeObserver) {
            window.fontSizeObserver.disconnect();
        }

        // Create new observer
        window.fontSizeObserver = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                mutation.addedNodes.forEach((node) => {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        // Apply font size to any text elements
                        if (node.tagName === 'text') {
                            node.style.setProperty('font-size', fontSize + 'px', 'important');
                            node.setAttribute('font-size', fontSize);
                        }
                        // Also check child text elements
                        const textElements = node.querySelectorAll('text');
                        textElements.forEach(text => {
                            text.style.setProperty('font-size', fontSize + 'px', 'important');
                            text.setAttribute('font-size', fontSize);
                        });
                    }
                });
            });
        });

        // Start observing
        window.fontSizeObserver.observe(mermaidContainer, {
            childList: true,
            subtree: true
        });
    }

    /**
     * Apply styles immediately to existing diagram elements without re-rendering
     */
    function applyStylesToExistingDiagram(fontSize, lineWidth, nodeBorder, cornerRadius) {
        const mermaidContainer = document.getElementById('mermaidContainer');
        if (!mermaidContainer) return;

        // Apply font size to all text elements immediately with aggressive targeting
        const textSelectors = [
            'text', 'svg text', 'g text',
            '.nodeLabel', '.edgeLabel', '.cluster-label', '.titleText',
            '.actor-label', '.messageText', '.loopText', '.noteText',
            '.labelText', '.classTitle', '.classText', '.stateText',
            '.er-entityNameText', '.er-attributeText'
        ];

        textSelectors.forEach(selector => {
            const textElements = mermaidContainer.querySelectorAll(selector);
            textElements.forEach(text => {
                // Apply multiple methods to ensure font size changes
                text.style.fontSize = fontSize + 'px';
                text.style.setProperty('font-size', fontSize + 'px', 'important');
                text.style.fontFamily = 'Segoe UI, Tahoma, Geneva, Verdana, sans-serif';
                text.setAttribute('font-size', fontSize);

                // Force style recalculation
                text.style.display = 'none';
                text.offsetHeight; // Trigger reflow
                text.style.display = '';

                // Debug logging
                console.log(`Applied font-size ${fontSize}px to text element:`, text.textContent, text);
            });
        });

        // Additional aggressive approach - remove any existing font-size styles first
        const allTextElements = mermaidContainer.querySelectorAll('*');
        allTextElements.forEach(element => {
            if (element.tagName === 'text' || element.textContent.trim()) {
                // Remove any existing font-size from style attribute
                if (element.style.fontSize) {
                    element.style.removeProperty('font-size');
                }
                // Apply new font size
                if (element.tagName === 'text') {
                    element.style.setProperty('font-size', fontSize + 'px', 'important');
                    element.setAttribute('font-size', fontSize);
                }
            }
        });

        // Apply node border styles to all shape elements immediately
        const shapeSelectors = [
            'rect', 'circle', 'ellipse', 'polygon', 'path.node',
            '.node rect', '.node circle', '.node ellipse', '.node polygon',
            '.actor', '.boundary', '.control', '.entity', '.database',
            '.classBox', '.state-start', '.state-end', '.stateBox',
            '.er', '.entityBox'
        ];

        shapeSelectors.forEach(selector => {
            const elements = mermaidContainer.querySelectorAll(selector);
            elements.forEach(element => {
                element.style.strokeWidth = nodeBorder + 'px';
                element.setAttribute('stroke-width', nodeBorder);
                if (element.tagName === 'rect' || element.tagName === 'ellipse') {
                    element.style.rx = cornerRadius + 'px';
                    element.style.ry = cornerRadius + 'px';
                    element.setAttribute('rx', cornerRadius);
                    element.setAttribute('ry', cornerRadius);
                }
            });
        });

        // Apply line width to edge elements immediately
        const lineSelectors = [
            '.edgePath path', '.flowchart-link', '.messageLine0', '.messageLine1'
        ];

        lineSelectors.forEach(selector => {
            const elements = mermaidContainer.querySelectorAll(selector);
            elements.forEach(element => {
                element.style.strokeWidth = lineWidth + 'px';
            });
        });
                                                                                                    }

                                                                /**
                                                                 * Initialize appearance settings on startup
                                                                 */
                                                                function initializeAppearanceSettings() {
                                                                    // Get current values from the UI
                                                                    const fontSize = document.getElementById('fontSize').value;
                                                                    const lineWidth = document.getElementById('lineWidth').value;
                                                                    const nodeBorder = document.getElementById('nodeBorder').value;
                                                                    const cornerRadius = document.getElementById('cornerRadius').value;

                                                                    // Apply initial appearance styles
                                                                    applyAppearanceStyles(fontSize, lineWidth, nodeBorder, cornerRadius);

                                                                    // Update range displays
                                                                    updateRangeDisplay('lineWidth', 'px');
                                                                    updateRangeDisplay('cornerRadius', 'px');
                                                                    updateRangeDisplay('nodeSpacing', 'px');
                                                                    updateRangeDisplay('rankSpacing', 'px');
        }

        function resetSettings() {
            // Reset theme
            document.querySelectorAll('.theme-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.style.border = '2px solid transparent';
            });
            document.querySelector('[data-theme="default"]').classList.add('active');
            document.querySelector('[data-theme="default"]').style.border = '2px solid #3498db';

            // Reset layout settings
            document.getElementById('diagramDirection').value = 'TD';
            document.getElementById('nodeSpacing').value = 50;
            document.getElementById('rankSpacing').value = 100;
            document.getElementById('curveStyle').value = 'basis';

            // Reset appearance settings
            document.getElementById('fontSize').value = 14;
            document.getElementById('lineWidth').value = 2;
            document.getElementById('nodeBorder').value = 2;
            document.getElementById('cornerRadius').value = 5;

            // Reset export settings
            document.getElementById('pngQuality').value = 2;
            document.getElementById('exportBackground').value = 'white';
            document.getElementById('exportFormat').value = 'png';
            document.getElementById('exportPadding').value = 20;
            document.getElementById('autoFitContent').value = 'true';

            // Update all range displays
            updateRangeDisplay('nodeSpacing', 'px');
            updateRangeDisplay('rankSpacing', 'px');
            updateRangeDisplay('lineWidth', 'px');
            updateRangeDisplay('cornerRadius', 'px');

            // Reset CSS custom properties
            const root = document.documentElement;
            root.style.removeProperty('--mermaid-font-size');
            root.style.removeProperty('--mermaid-line-width');
            root.style.removeProperty('--mermaid-border-width');
            root.style.removeProperty('--mermaid-corner-radius');

            // Remove custom styles
            const customStyleElement = document.getElementById('mermaid-custom-styles');
            if (customStyleElement) {
                customStyleElement.remove();
            }

            // Reinitialize Mermaid with default settings
            initializeMermaid();

            // Re-initialize appearance settings
            initializeAppearanceSettings();

            // Re-render diagram
            renderDiagram();
            showSuccess('All settings reset to defaults! üîÑ');
        }

        // ===== URL PARAMETER HANDLING =====
        function loadFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const encodedCode = urlParams.get('code');

            if (encodedCode) {
                try {
                    const code = decodeURIComponent(escape(atob(encodedCode)));
                    document.getElementById('code').value = code;
                    renderDiagram();
                    showSuccess('Diagram loaded from URL! üîó');
                } catch (e) {
                    showError('Invalid URL parameters.');
                }
            }
        }

        // Load from URL on page load
        window.addEventListener('DOMContentLoaded', function () {
            // Small delay to ensure other initialization is complete
            setTimeout(loadFromURL, 100);
        });

        // ===== DEFAULT CONTENT =====
        function setDefaultContent() {
            if (!document.getElementById('code').value.trim()) {
                document.getElementById('code').value = `Welcome to Interactive Canvas Editor!

üéØ Features:
- Drag boxes around the canvas
- Lines automatically follow connected boxes
- Smooth animations and interactions
- Export your diagrams as PNG

üöÄ Getting Started:
1. Click "Add Box" to create new boxes
2. Drag boxes to move them around
3. Lines stay connected automatically
4. Use zoom controls for better view
5. Export when ready!

üí° Tips:
- Use Ctrl+N to add new boxes quickly
- Grid can be toggled for alignment
- All interactions are smooth and responsive`;
            }
        }

                                                /**
                                                 * Comprehensive export testing function for development/debugging
                                                 * Tests export functionality at various zoom levels and validates content
                                                 */
                                                function testExportFunctionality() {
                                                    console.log('üß™ Starting comprehensive export functionality test...');

                                                    // Test data - various diagram types
                                                    const testDiagrams = [
                                                        {
                                                            name: 'Simple Flowchart',
                                                            code: `graph TD
    A[Start] --> B{Decision}
    B -->|Yes| C[Action 1]
    B -->|No| D[Action 2]
    C --> E[End]
    D --> E`
                                                        },
                                                        {
                                                            name: 'Sequence Diagram',
                                                            code: `sequenceDiagram
    participant A as Alice
    participant B as Bob
    A->>B: Hello Bob!
    B-->>A: Hello Alice!
    Note over A,B: Communication established`
                                                        }
                                                    ];

                                                    // Test zoom levels
                                                    const zoomLevels = [0.5, 1.0, 2.0];

                                                    let testResults = [];

                                                    testDiagrams.forEach((diagram, diagramIndex) => {
                                                        console.log(`Testing diagram: ${diagram.name}`);

                                                        // Set diagram code
                                                        document.getElementById('code').value = diagram.code;
                                                        renderDiagram();

                                                        // Wait for render to complete, then test at different zoom levels
                                                        setTimeout(() => {
                                                            zoomLevels.forEach((zoomLevel, zoomIndex) => {
                                                                console.log(`Testing at zoom level: ${zoomLevel}x`);

                                                                // Set zoom level
                                                                currentScale = zoomLevel;
                                                                applyTransform();

                                                                // Test export
                                                                setTimeout(() => {
                                                                    const cleanSvg = getCleanSVGForExport();
                                                                    if (cleanSvg) {
                                                                        const fixes = autoFixExportContent(cleanSvg);
                                                                        const bounds = calculateSVGContentBounds(cleanSvg);

                                                                        testResults.push({
                                                                            diagram: diagram.name,
                                                                            zoom: zoomLevel,
                                                                            fixes: fixes,
                                                                            bounds: bounds,
                                                                            timestamp: new Date().toISOString()
                                                                        });

                                                                        console.log(`‚úÖ Test completed for ${diagram.name} at ${zoomLevel}x zoom`);

                                                                        // If this is the last test, show results
                                                                        if (diagramIndex === testDiagrams.length - 1 && zoomIndex === zoomLevels.length - 1) {
                                                                            console.log('üéâ All export tests completed!');
                                                                            console.table(testResults);

                                                                            // Reset to normal state
                                                                            currentScale = 1.0;
                                                                            applyTransform();
                                                                            showSuccess('Export functionality test completed! Check console for results. üß™');
                                                                        }
                                                                    }
                                                                }, 500);
                                                            });
                                                        }, 1000 * diagramIndex + 500);
                                                    });
                                                }

                                                // Add test function to window for manual testing
                                                window.testExportFunctionality = testExportFunctionality;

        // Set default content after a short delay to ensure DOM is ready
        setTimeout(() => {
            setDefaultContent();
        }, 200);
    </script>
</body>

</html>